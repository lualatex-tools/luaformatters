%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is the manual for the luatemplates package.
% Along with the files
% - luatemplates-manual-config.lua
% - luatemplates-manual-config-mwe.lua
% the source itself serves as documentation to the package,
% its use and programming.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{scrartcl}

\RequirePackage{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% The following includes are general for the writing of this document
%% and not related to the working of luatemplates
\RequirePackage{fontspec}
\RequirePackage{microtype}
\RequirePackage[oldstyle,proportional]{libertine}
\setmonofont[Scale=MatchLowercase,StylisticSet=1]{InconsolataN}
\defaultfontfeatures{
	Ligatures=TeX,
	Scale=MatchLowercase,
	Numbers=Proportional,
	Numbers=OldStyle
}
\frenchspacing
\RequirePackage{graphicx}
\RequirePackage{mdwlist}
\usepackage{varioref}
\usepackage[colorlinks]{hyperref}
\usepackage{cleveref}
%% End general includes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Use or require the `luatemplates` package with (some of the) options
% NOTE: option self-documentation implicitly loads minted, so that doesn't
% have to be included explicitly for the writing of this document.
\usepackage[
color,              % use colors
self-documentation, % Create the self-documentation commands
]{luatemplates}

% Set up the Templates object, passing a variable name prefix
% and a configuration file name.
% The Templates object will later be globally available to Lua by the name
% manual_templates and could be adressed as such from any \directlua command.
% luatemplates-manual-config.lua must be findable by LaTeX.
\addLuaTemplates{luatemplates-manual-templates}

% Add further templates files. Separate clients are added to be able to
% *list* them at the end of the manual.
\addLuaTemplates{examples/closure}

% Remaining functionality that is used in the manual
% but not suitable for listings
\addLuaTemplates{examples/additionals}

\setminted[lua]{tabsize=4}

\title{\luatemplates}
\subtitle{v0.8}
\author{Urs Liska}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}

\package{luatemplates} is a package for Lua\LaTeX\ designed to assist package
and document authors with the recurring task of \emph{templating}.  Essentially
it eliminates the need to deal with the interfacing of the \LaTeX\ and Lua sides
of creating macros.  The package's main objectives are: maintaining  templates
and formatter functions in a central location, easily exposing them as \LaTeX\
macros, and assisting with a modular style of programming templates and styles.

\end{abstract}


\tableofcontents

\section{Introduction}

Templating is one of the most common techniques applied when writing \LaTeX\
packages, especially when Lua is involved which encourages using \LaTeX\ not
only as a \emph{typesetting} but also as a \emph{document/content generation}
system.  Very often one takes some data (from macro arguments), processes it
more or less heavily (ranging from simply \emph{styling} it to taking arguments
as lookup keys to arbitrarily complex data), and merges it into some kind of
template to produce the final result being written back to the \LaTeX\ document.
When I started to regularly make use of that pattern I realized that in every
case I ended up wanting to concentrate my style and template configuration at a
central place, which usually became a Lua table in a config file.  Following the
DRY paradigm and creating a \emph{package} with support for templating seemed
like a good idea, and watching my configuration and style files shrink to
extraordinary shortness and clarity during the development process was indeed a
pretty inspiring experience.  By now the package allows the definition of
templates and formatter functions in a nearly “declarative” style, while the
corresponding \LaTeX\ macros are generated automatically. Additionally the
package provides tools for and encourages using modular approaches to creating
templates and styles.

This manual is of course written using \package{luatemplates}, and therefore it
is strongly recommended to study the sources too, not only the compiled PDF
file.  Depending on the installation type these may be found in different
places.  If you read this from a \TeX\ Live installation try \texttt{kpsewhich
luatemplates.tex} and \texttt{kpsewhich luatemplates-manual-config.lua} to get
their exact location.  \emph{Basic} and \emph{minimal} working examples are
listed later in this manual (\vref{sec:mwe} and
\vref{sec:basic-sample-config}), and they are also available as files beside
the sources for this manual.%
\footnote{\url{https://github.com/uliska/luatemplates/tree/master/documentation}.\\
\textbf{TODO:} Clarify where they end up in TeX Live.}

\subsection{Dependencies and Installation}
\label{sec:dependencies-and-installation}

The package depends on the \package{lyluatextools} package, which is at this
point only available through the development repository of \package{lyluatex} at
\url{https://github.com/jperon/lyluatex}.  When \package{luatemplates} will be
released to CTAN and eventually hit the \TeX\ distributions we'll make sure the
package releases are in sync.

Installation is done the usual way, by making the package's files
\texttt{luatemplates.sty} and \texttt{luatemplates.lua} available to the
\textsc{texmf} tree. Note that at this point the package can only be used from
the Github development repository at
\url{https://github.com/uliska/luatemplates}.

\textbf{NOTE:} It should go without saying, but better safe than sorry: Since
this package relies heavily on Lua code it can only be compiled with
\package{lualatex}.


\subsection{Basic Concepts}
\label{sec:basic-concepts}

When working with Lua\LaTeX\ to create complex documents or packages the
incentive for using Lua is usually the more powerful and more accessible way of
manipulating text and data with Lua than it is possible with traditional \LaTeX\
programming.  One common idiom in this context is to get the data from the \TeX\
to the Lua domain as quickly as possible, process it there and only write the
final result back to the \TeX\ document.  However, this can involve significant
overhead that is not always worth the effort and can leave the code in a
confusing mix of \LaTeX\ and Lua.  What I've repeated several times in new
projects is creating an infrastructure to retrieve templating data from a Lua
table and make that available to my \LaTeX\ macros.  The basic idea of this
package is to make this as automatic as possible by providing tools to
\emph{declare} “formatters” (templates and formatter functions) in one Lua table
and have them exposed as \LaTeX\ macros mostly automatically, simply by passing
it to an initialization method. I'll go into more detail soon, but just consider
the following excerpt from a Lua configuration table:

\begin{minted}{lua}
MY_TEMPLATES = {
    formatters = {
        cmd = [[\textbf{\textbackslash <<<name>>>}]]
    }
}
\end{minted}

\noindent which will automatically create a command
\luaMacroDocInline{cmd}
with one mandatory argument that can be used in the \LaTeX\ document (and is so
throughout this document) without any further set-up work.  And a Lua function

\label{code:function}
\begin{minted}{lua}
function MY_TEMPLATES.formatters:reverse(text, options)
    options = self:check_options(options)
    local result = text:reverse()
    if options.upper then
        result = result:upper()
    end
    return result
end
\end{minted}

\noindent will create a macro \luaMacroDocInline{reverse} with an optional
argument that can be used like

\luaMacroDoc[demo,nocomment,%
demosep=\par\noindent producing ,%
args={upper,The brown fox}]{reverse}%
in the output.  There are four things
to highlight at this point, which are detailed further in the following sections
of the manual:

\begin{itemize*}
\item The handling of optional and mandatory arguments for the \LaTeX\ macro is
done automatically, inferring the details directly from the Lua function's signature.
\item Through the use of \package{lyluatexoptions} the handling of optional
\texttt{key=value} arguments has become incredibly simple.  With some more
administrative effort (setting up one's own options instance) their keys and
values can even bevalidated.
\item The package provides helper functions and encourages to go forward with
this approach to follow modular design principles.
\item Output can be colored automatically and conditionally, without having to
hard-code coloring into the macros. This can equally be used to actually create
colored output and to use coloring as a visual checker for correct entry.
\end{itemize*}


\section{Usage}
\label{sec:usage}

\subsection{Setting Things Up}
\label{sec:setup}

To use \package{luatemplates} in a document three steps have to be performed,
two of which being extremely straightforward. First of all the package
has to be loaded:

\begin{minted}{tex}
\usepackage{luatemplates}
\end{minted}

\noindent There are a number of package options that configure the behaviour,
which will be discussed in \vref{sec:option-handling}.

Once the package is loaded a global variable \luavar{lua\_templates} is
available within any Lua chunks.  This references the \luavar{Templates} table
defined in the package.  Usually it will not be necessary to address this
directly, rather it is used for the operation of the automatically generated
\LaTeX\ macros (\vref{sec:creating-macros}), however there may be occasions
where it is good to know the global variable is there.

\medskip

The main work happens in an external Lua file/module, which is expected to
return one single table holding all the declarations and implementations for the
desired templates and macros.  The usage, structure, and programming of this
table will be covered in the rest of this manual.

\medskip

Finally the templates table has to be “installed” to the system:

\begin{minted}{tex}
\addLuaTemplates(<name>, <file name>)}
\end{minted}

This registers the \emph{templates table} from \texttt{<file name>} as a
“client“ of the templating system.  This is all that has to be done on the
\LaTeX\ side to set up \package{luatemplates}.  A Minimal Working Example
consisting of a \texttt{.lua} and a \texttt{.tex} file is listed in
\vref{sec:mwe}.

Multiple templates tables can be added to the templating system, for example by
loading multiple packages that make use of the system, or to compose the final
macro library from various modules.  Templates tables can also \emph{use}
functionality provided by other registered templates tables.%
\footnote{\textbf{TODO:} Currently there is no consistent handling when
Formatter Tables cause name clashes of any sorts. Tables added later will
silently overwrite previous declarations, possibly breaking everything. This has
to be resolved, see \url{https://github.com/uliska/luatemplates/issues/24}.}


\subsection{The Templates Table}
\label{sec:templates-table}

A \emph{Templates Table} is a Lua table with a certain structure in which the
behaviour, the interface, and above all the \emph{formatters} are defined that
will be automatically made available as \LaTeX\ macros. A \emph{formatter} is a
Lua object which is internally powered by either a \emph{template string} or a
\emph{formatter function}.  From each formatter that is not marked as hidden a
\LaTeX\ macro is created which later \emph{use} the formatter to process the
macro's arguments and optionally apply coloring to the result. This separation
of concerns makes it possible for formatters to \emph{use} other formatters
entirely in the Lua domain, encouraging modular or “cascading” approaches to
developing stylesheets. If not explicitly specified the macro's name is inferred
from the configuration table structure.

The following subsections describe the mandatory and optional elements that can
be part of the configuration table.


\subsubsection{Multiple Clients}
\label{sec:multiple-clients}

Multiple template tables can be registered as clients for the templating system,
and their behaviour is partially merged and partially not.  The tables
themselves are stored side by side within the global \luavar{Templates} table,
and their code is basically private to them.  However, their published
formatters are merged into one list of formatters, giving all clients access to
all other formatters.  At this point it has not been decided how name conflicts
should be handled (presumably this will be made configurable), currently
elements provided by template tables added later will silently overwrite
existing elements, which would pretty likely cause serious problems.


\subsubsection{Configuration}
\label{sec:templates-table-configuration}

\paragraph{\luavar{prefix}}

The templates table can have an optional field \luavar{prefix} which
defaults to an empty string.  This prefix will be given to any generated macro
names and is therefore especially relevant when writing \emph{packages} rather
than using \package{luatemplates} for individual documents.  If this field is
set to \luavar{ltx} a macro would for example be named \cmd{ltxBookName} instead
of \cmd{bookName}.

\begin{minted}{lua}
MY_TEMPLATES = {
    prefix = 'ltx',
}
\end{minted}


\paragraph{\luavar{display\_name}}

A templates table can have an optional field \luavar{display\_name} which
defaults to the name passed to \mintinline{tex}{\addLuaTemplates}.  Currently
this field is not actively supported, but it is intended to be used in the
self-documentation features (\vref{sec:self-documentation}).


\paragraph{\luavar{configuration}}

An optional subtable \luavar{configuration} may be used to either provide
additional configuration data to formatters (\vref{sec:configuring-macros}) or
to create \LaTeX\ macros from built-in formatters
(\vref{sec:exposing-builtin-formatters}).


\subsubsection{The Formatter Table}
\label{sec:formatter-table}

The mandatory field in a templates table is the \luavar{formatters} subtable. It
may be arbitrarily nested with further subtables that serve both for organizing
the material and for defining the namespace of generated macro names, which are
by default derived from the table structure.  Each field (with the exception of
subtable nodes) is expected to be a valid \emph{formatter entry} (see next
section) declaring and/or implementing a \emph{formatter}.  All formatters
declared in the \luavar{formatters} subtable are also available to the other
clients of the templating system (while other toplevel fields can be considered
private to the client).


\subsubsection{Formatter Entries}
\label{sec:formatter-entries}

Each leaf in a formatter subtable that is not itself a namespace node holds the
declaration of one formatter, which can be coded as one out of:

\begin{itemize*}
\item A (template) string
\item A function (returning a single string)
\item A proper \emph{formatter entry table}
\end{itemize*}

Standalone templates or functions will be implicitly wrapped in basic formatter
entry tables:

\begin{minted}{lua}
MY_TEMPLATES = {
    formatters = {
        abbr = function(self, text) return text:sub(1, 3) .. '.' end,
        LoC = [[Library of Congress]],
    }
}
\end{minted}

\noindent will implicitly be understood as:

\begin{minted}{lua}
MY_TEMPLATES = {
    formatters = {
        abbr = {
            f = function(self, text) return text:sub(1, 3) .. '.' end,
        },
        LoC = {
            f = [[Library of Congress]],
        },
    }
}
\end{minted}

\noindent where the actual formatter (template or function) is recast as the
\luavar{f} field within a formatter entry table. The general recommendation is
to use formatter entry tables in all but the most simple projects because they
make the code more explicit, especially in combination with the self-documenting
features described in \vref{sec:self-documentation}.  For a way to first
\emph{declare} the formatter and then \emph{configure} the details see
\vref{sec:configuring-macros}, which is typically done for formatter functions that are defined using the regular function definition syntax rather than being directly assigned in the table constructor:

\begin{minted}{lua}
function MY_TEMPLATES.formatters:abbr(text)
    return text:sub(1, 3) .. '.'
end
\end{minted}

Each formatter whose name (which is defined either by the table key or an
explicit \luavar{name} field) doesn't start with an underscore will implicitly
trigger the creation of a \LaTeX\ macro, for which all available information
(inferred or provided) is used.  See \vref{sec:creating-macros} for details.

For details about writing formatters refer to \vref{sec:defining-formatters} and
\vref{sec:advanced-programming}.

\paragraph{Formatter Entry Tables}

The formatter entry table is a flat table with one mandatory and a number of
(conditionally) optional fields:

\paragraph{\luavar{f}}

The mandatory field \luavar{f} (as in \textbf{f}ormatter) holds the actual
formatter, either a template string or a formatter function, as seen just above.


\paragraph{\luavar{name}}

By default the name of the generated \LaTeX\ macro is inferred from the
formatter's position in the table hierarchy, converting the Lua-style dot
notation to a mixed case name.  A formatter stored in \luavar{music.composer}
will produce the macro \cmd{musicComposer} (if no prefix is defined).  With the
\luavar{name} field an explicit name can be specified, circumventing the
automatic name generation.  NOTE (reminder): if the formatter's name resulting
from either its field key or the \luavar{name} field starts with an underscore,
no \LaTeX\ macro will be created for the formatter.


\paragraph{\luavar{comment}}

A \luavar{comment} is generally useful as a visual reminder about what the
formatter is intended to do or represent.  However, beyond its use as a source
code comment it can be used as part of the auto-generated documentation which is
described in \vref{sec:self-documentation}.


\paragraph{\luavar{color}}

With the \luavar{color} field the default color can be overridden, or coloring
can be skipped completely with the option \luavar{'nocolor'}.  See
\vref{sec:coloring} for details of the package's color handling.


\paragraph{\luavar{args}}

An array table \luavar{args} controls the mapping of macro arguments to template
fields in templates with multiple fields.  \luavar{args} is required for
\emph{templates} with more than one mandatory argument and will be ignored for
templates with zero or one mandatory arguments.  It is also ignored for
\emph{formatter functions} whose arguments are completely inferred by
introspection.  See \vref{sec:templates-templates} and
\vref{sec:formatter-functions} for details.


\paragraph{\luavar{opt}}

If the formatter features an optional argument the \luavar{opt} field (if
present and holding a non-empty string) controls the default value that is
provided in the generated \LaTeX\ macro.  See
\vref{sec:templates-argument-handling} and
\vref{sec:functions-argument-handling} for details.

\bigskip

As documented above all but the \luavar{f} fields are optional in most cases,
and you will usually only need a few of them for a reasonably encoded formatter.
\Vref{fig:bookShort} shows \emph{all} fields in action, implicitly creating the
macro \luaMacroDocInline{bookShort} with a possible use shown in
\vref{fig:bookShortUse}. \Vref{sec:basic-sample-config}) lists a complete basic
configuration file, showing a bare minimum of code but covering all features.

\begin{figure}
\begin{minted}{lua}
MY_TEMPLATES = {
    formatters = {
        book = {
            name = 'bookShort',
            comment = 'A book definition for inline use',
            f = [[\textbf{<<<author>>>}: \emph{<<<title>>>} (<<<year>>>)]],
            color = 'magenta',
            args = {'author', 'title', 'year'},
            -- opt does not make sense here
        }
    }
}
\end{minted}
\caption{A “complete” formatter entry table}
\label{fig:bookShort}
\end{figure}

\begin{figure}
\luaMacroDoc[demo,args={Schoenberg,Style and Idea,1950}]{bookShort}.
\caption{Use and result of an automatically generated macro.}
\label{fig:bookShortUse}
\end{figure}


\subsection{General Techniques}
\label{sec:general-techniques}

There are a few common concepts and general techniques that are worth introducing separately,
although some of the material has to be detailed later.  One of the more
interesting features of the \package{luatemplates} package is the implicit color
handling which simplifies the creation of macros for actually colored documents
or can serve as a handy “draft” tool.  Another important feature is the handling
of macro arguments, which the package can process automatically to a surprising
percentage.  But to start off with, option handling is described.


\subsubsection{Option Handling}
\label{sec:option-handling}

\package{luatemplates} makes use of the option handling features of the
\package{lyluatex} package.%
\footnote{\textbf{NOTE:} Currently it is not clear to what extent these features will
be factored out to an independent package, possibly merged with \package{luatemplates}.
Also it is not clear whether there will be an independent manual for the option handling
tools.} %
This includes the handling of \package{luatemplates}' own package options as
well as providing tools to deal with optional arguments in formatter functions
and created \LaTeX\ macros.  Additionally it is possible to integrate that with
standalone instances of \package{lyluatextools}, which will only be touched in
\vref{sec:advanced-programming}.

\package{luatemplates} has a number of package options which will be described
below.  These can be set upon package loading or at any point during the
document, although not all options may \emph{reasonably} be changed after
loading.  Package options are specified using the \texttt{key=value} syntax, but
boolean values can be set to \texttt{true} by simply passing their name:
\luavar{[color]} is equivalent to \luavar{[color=true]}.

\cmd{luatemplatesSetOption\{key\}\{value\}} can be used to change the value of
an option during the course of the document.  However, depending on the option
this may or may not have any or the desired results, see below for details.
Note that boolean values always have to be given explicitly (other than when set
as package options).

The following package options are available, note that many of them don't affect
the general operation of the package but the behaviour of specific
\emph{built-in formatters} (see \vref{sec:builtin-formatters}).


\paragraph{\luavar{color} (boolean, false)}

If set macros are wrapped in a \cmd{textcolor} macro (if not suppressed through
the macro configuration),  see \vref{sec:coloring} for details about the
coloring concept.  If the option is set as a package option it is checked
whether either the \package{color} or the \package{xcolor} packages are already
loaded, and if neither is, \package{xcolor} is loaded implicitly.

This has the following implication: if \luavar{color} is \emph{not} given as a
package option and no color package has been loaded otherwise it is \emph{not}
possible to set the option to \texttt{true} later in the document.  However, if
a coloring package is loaded (explicitly or implicitly) coloring can be turned
on and off at will throughout the document.

\paragraph{\luavar{default-color} (blue)}

The color used for coloring macros if no other color is specified for a macro or
coloring is switched off for that macro through the pseudo-color
\luavar{'nocolor'}.


\paragraph{\luavar{element-separator} (,)}

Separator to be used in the built-in formatter \luavar{add\_element}.%
\footnote{\textbf{NOTE:} This is affected by
\url{https://github.com/uliska/luatemplates/issues/5}.}


\paragraph{\luavar{number-case} (normal)}

Configuration of the built-in formatter \luavar{number}.  This formatter
provides case handling for consistent appearance of roman numerals (e.g. in
pagination).  Possible values are:

\begin{itemize*}
\item \luavar{normal} (default): leave input unmodified
\item \luavar{smallcaps}: Apply the small caps function
\item \luavar{allsmallcaps}: Convert to lowercase, \emph{then} usd small caps
\item \luavar{upper}: uppercase
\item \luavar{lower}: lowercase
\end{itemize*}

\noindent Note that this will also be applied for \emph{text} if it should
happen to be included in an argument supposedly holding a number.

\paragraph{\luavar{range-follow} / \luavar{range-ffollow} (f. / ff.)}

Text to be used for “f.” or “ff.” (as in “and following”).  Used by the built-in formatter \luavar{range}.


\paragraph{\luavar{range-sep} (\texttt{--})}

Separator used when printing a range.  Used by the built-in formatter \luavar{range}.


\paragraph{\luavar{list-sep} (', ')}

Separator used for all but the last elements of a list produced by the built-in formatter
\luavar{list\_format}.%
\footnote{\textbf{NOTE:} This is affected by
\url{https://github.com/uliska/luatemplates/issues/5}.}


\paragraph{\luavar{list-last-sep} (' and ')}

Separator used for the last two elements of a list produced by the built-in formatter
\luavar{list\_format}.%
\footnote{\textbf{NOTE:} This is affected by
\url{https://github.com/uliska/luatemplates/issues/5}.}


\paragraph{\luavar{self-documentation} (boolean, false)}

If set at package loading this option enables the self-documentation features
described in \vref{sec:self-documentation}.


\subsubsection{Coloring}
\label{sec:coloring}

If the package option \luavar{color} is set to \texttt{true}
\package{luatemplates} supports automatic coloring in various ways.  By default
all macros produced by the package are wrapped in a \cmd{textcolor} macro and
set to the package's \luavar{default-color} option value.  If not set to a
different color (see \vref{sec:option-handling}) this will be \texttt{blue}
(as can be seen throughout most of this manual).  However, if a formatter entry
specifies a different \luavar{color} value this will be used instead of the
package default.  The idea behind this feature is that I really like to use
colors as a visual indicator in “draft” mode to help me make sure the document
is coded properly with the correct semantic markup.  Oftentimes various
different items will end up styled identically, for example with simple emphasis
or boldface.  Assigning different colors to the styles is a visual aide for
proofreading the document, and \package{luatemplates}' approach is a useful tool
to make this technique easily configurable and “switchable”.

Note that if a macro hardcodes a \cmd{textcolor} element in the template itself
it will override the package's handling mechanism, and it will also persist once
the \luavar{color} option is switched off in the package.


\paragraph{\luavar{nocolor}}

If the \luavar{color} field is set to the special value \luavar{'nocolor'} then
the coloring step is skipped completely, so the macro is not set to be black but
not wrapped in \cmd{textcolor} in the first place.  This may be desirable to
have some commands \emph{always} be printed in black, but more importantly it
may be necessary to avoid some macros to break if they can't reasonably be
wrapped in a color -- for example if they produce an environment rather than
simply formatted text.


\subsubsection{Creating Macros}
\label{sec:creating-macros}

One of the main features of this package is the automatic creation of \LaTeX\
macros from formatter declarations.  This section describes how that is done and
what has to be provided.

By default all formatters registered in the configuration table will
automatically produce a corresponding macro, using information that can be
inferred or that has been provided by the formatter entry table.  Macro
arguments are set up appropriately depending on the formatter's type (see
information scattered throughout \vref{sec:defining-formatters}), and the name
is either inferred from the position in the templates table or by an
explicitly given \luavar{name} field.  For example, if a formatter is located at
\luavar{music.composer.catalogue} its generated macro name would be
\cmd{musicComposerCatalogue}.  If the \luavar{prefix} value is set in the
configuration table this will be used for the generated macro name as well.
However, if the formatter's name starts with an underscore, \emph{no} macro is
created automatically.  This is used to create formatters for internal use by
other formatters that are not intended to be accessible from the \LaTeX\
document.  An example would be a formatter located at \luavar{literature.\_isbn}
or with a \luavar{name} field \luavar{\_load\_metadata}.%

Since Lua key names may include underscores whily \LaTeX\ macros don't
underscores are automatically sanitized to mixecCase in generated macro names,
so a formatter stored in \luavar{load\_metadata} will be converted to the macro
\cmd{loadMetadata}.


\subsubsection{Configuring Macros}
\label{sec:configuring-macros}

Sometimes it is inconvenient to specify all relevant information in a formatter
entry table directly when registering a formatter.  Most commonly this will
apply to formatter \emph{functions} which typically will be written using Lua's
function definition idiom rather than directly be assigned in a table
constructor (see \vref{sec:formatter-functions}).  For these cases it is
possible to add information to existing formatters in a \luavar{configuration}
subtree of the main configuration table.  This is a flat table whose entries are
very similar to the formatter entry tables described in
\vref{sec:formatter-table}, with some subtle differences described
now.

The \emph{keys} of this table are \emph{macro names}, so a field
\luavar{MY\_TEMPLATES.configuration.bookShort} will configure a \LaTeX\ macro
\cmd{bookShort}.
Each key is associated with a configuration table for a single macro/formatter,
which is located by the mandatory field \luavar{key}.  This is a string
addressing a node in the formatter tree, using Lua-style dot-notation, so
\texttt{bookShort = \{ key = 'literature.book' \}} will cause the formatter at
\luavar{literature.book} to create a macro \cmd{bookShort} instead of
\cmd{literatureBook}.

Since the macro name is now defined through the table's parent field name, and
the formatter is located through the \luavar{key} field, both the \luavar{f} and
the \luavar{name} fields of the formatter entry table are not considered anymore
(technically they are overwritten), apart from this the table's fields  behave
exactly like those in the formatter entry tables describe in
\vref{sec:formatter-entries}.

\begin{minted}{lua}
MY_TEMPLATES = {
    configuration = {
        revText = {
            key = 'reverse',
            comment = 'Reverse the given string, optionally in small caps.',
            color = 'red',
        }
    }
}
\end{minted}

\noindent
This entry configures a formatter at the toplevel position \luavar{reverse} to
create the macro \cmd{revText} and adds the color and the comment to its
configuration.

\subsubsection{Exposing Built-in Formatters}
\label{sec:exposing-builtin-formatters}

In addition to completing the information for registered formatters the
\luavar{configuration} subtable can also be used to expose built-in formatters
as \LaTeX\ macros. \package{luatemplates} implements a number of built-in
formatter functions that are primarily useful for use by \emph{other} formatters
but also provide convenient end-user macros for general formatting tasks.  Since
they have pretty generic names it didn't seem like a good idea to create macros
for them by default, but this way one can selectively expose them to \LaTeX\
while at the same time exercising control over the macro names.

Since built-in formatters are always \emph{functions} it is not necessary to
provide \luavar{args}, but comments and colors may be useful additions. However,
there is also a shorthand notation by simply assigning the formatter's key to
its intended name.  In this case the built-in formatter is exposed by the given
name without any further configuration:

\begin{minted}{lua}
MY_TEMPLATES = {
    configuration = {
        names = 'list_format',
    }
}
\end{minted}

\noindent creates the macro \luaMacroDocInline{names} from the built-in
formatter \luavar{list\_format}, correctly assigning the optional and the
mandatory \luavar{text} argument.

Besides being converted to \LaTeX\ macros built-in formatters can be accessed
and used from Lua code.  For details about the use and documentation of
available formatters see \vref{sec:builtin-formatters}.


\subsubsection{Self-Documentation}
\label{sec:self-documentation}

While it is simple to \emph{declare} formatters and create \LaTeX\ macros from
them it is not always easy to see how they have to be \emph{used} in documents.
This is especially a concern for package writers who are not the consumers of
their own macros (well, actually it's more a problem for the \emph{users} of a
package who are not the \emph{authors} of the macros \dots).  To help with that
situation \package{luatemplates} provides a self-documentation feature, which is
also useful for bug-tracking. When the package is loaded with the
\luavar{self-documentation} package option set, two things happen: “docstrings”
are generated for each formatter, and a number of \LaTeX\ macros to typeset the
documentation are created.

\medskip

\noindent \textbf{NOTE:} self-documentation is powered by \package{minted}, with
the following implications:

\begin{itemize*}
\item The \package{minted} \LaTeX\ package has to be installed.
\item \package{Pygments} has to be available and configured (see the \package{minted} manual for details).
\item \LaTeX\ has to be started with the \texttt{--shell-escape} option to
allow the start of external programs (Pygments, a Python program).  Please make
sure that you understand the security implications of this decision.
\item Note that this applies to compiling this manual as well.
\end{itemize*}

\paragraph{General options}

The self-documenting macros are governed by a number of options that apply to
all types of documentation string (if not mentioned otherwise).

\begin{itemize}
\item \luavar{args}\\
By default the docstring prints the argument \emph{names} as specified in the
template or function.  But if \luavar{args} is provided as a comma-separated
list (wrappped in curly brackets) the values are used to replace the argument
names.  Note that this is not a \texttt{key=value} table but a list of arguments
that are used in order of appearance.
\item \luavar{demo}\\
By default just a documentation string of the macro is typeset.  If the
\luavar{demo} option is given, then additionally an \emph{example} of the macro
use is given.
\item \luavar{demosep}\\
If a usage demo is printed it is separated from the documentation string by a
separator that is specific to the command used for the documentation (described
below).  However, if \luavar{demosep} is given as an option it is used instead.
\item \luavar{nocomment}\\
If this option is set a comment stored with the formatter is not printed.
\end{itemize}

\paragraph{\mintinline{tex}{\luaMacroDocInline[options]{command}}}

This command produces documentation for a single macro and inserts it at the
current position (i.e. within the current paragraph).  An available comment in
the formatter will be ignored, so the \luavar{nocomment} options doesn't have
any effect with this command.

\begin{itemize}
\item \mintinline{tex}{\luaMacroDocInline{reverse}}\\
produces \luaMacroDocInline{reverse}, documenting the macro name and its
arguments.  Here the argument names specified in the template or function are
used, so that's an incentive to use well-decided names.
\item \mintinline{tex}{\luaMacroDocInline[args={smallcaps,The brown fox}]{reverse}}\\
produces \luaMacroDocInline[args={smallcaps,The brown fox}]{reverse}, inserting
the provided arguments to give a usage example.
\item \mintinline{tex}{\luaMacroDocInline[demo,args={smallcaps,The brown fox}]{reverse}}\\
produces \luaMacroDocInline[demo,args={smallcaps,The brown fox}]{reverse},
adding a \emph{typeset} rendering of the command. (Note that this may be
particularly useful for debugging purposes.)
\item \mintinline{tex}{\luaMacroDocInline[demo,demosep={ => },args={smallcaps,The brown fox}]{reverse}}\\
produces \luaMacroDocInline[demo,demosep={ => },args={smallcaps,The brown fox}]{reverse}, replacing the default colon with a custom separator between docstring and result.
\end{itemize}


\paragraph{\mintinline{tex}{\luaMacroDoc[options]{command}}}

This command produces documentation for a single macro and inserts it wrapped in a \luavar{minted} environment.  If one is available a formatter comment is displayed too.

\medskip
\noindent \mintinline{tex}{\luaMacroDoc{reverse}} --\\
provides the default documentation for the command:

\luaMacroDoc{reverse}

\medskip
\noindent \mintinline{tex}{\luaMacroDoc[nocomment]{reverse}} --\\
provides the default documentation for the command, but without the comment:

\luaMacroDoc[nocomment]{reverse}

\medskip
\noindent \mintinline{tex}{\luaMacroDoc[args={smallcaps,The brown fox}]{reverse}} --\\
uses the given argument values:

\luaMacroDoc[args={smallcaps,The brown fox}]{reverse}

\medskip
\noindent \mintinline{tex}{\luaMacroDoc[demo,args={smallcaps,The brown fox}]{reverse}} --\\
uses the given argument values and adds a demo in a new paragraph:

\luaMacroDoc[demo,args={smallcaps,The brown fox}]{reverse}

\medskip
\noindent \mintinline{tex}{\luaMacroDoc[demo,demosep={\par\hrule\par\bigskip\noindent},args={smallcaps,The brown fox}]{reverse}} --\\
additionally specifies a custom separator:

\luaMacroDoc[demo,demosep={\par\hrule\par\bigskip\noindent},args={smallcaps,The brown fox}]{reverse}


\paragraph{\mintinline{tex}{\luaMacroDocClient[options]{client-name}}}

produces a sorted list of macro documentations for a given “client”.  As there seems no reasonable way to do it the \luavar{demo} (and related) options have no effect on this command.  The same is true for the \luavar{args} option.
Configuration of the appearance is currently on the wishlist \dots

\medskip

\noindent \mintinline{tex}{\luaMacroDocClient[nocomment]{manual}} produces the
list of macros defined in this manual's template table (some of them are created
for \emph{use} in the manual, others for demonstrating purposes).  Leaving out
the \luavar{nocomment} option would add the comments for formatters that have
one defined. (The output is wrapped in a \texttt{quote} environment for better clarity):

\begin{quote}
\luaMacroDocClient[nocomment]{manual}
\end{quote}

\bigskip

\hrule

\bigskip

\noindent \textbf{TODO:} There are a few open ends and functionality that has to be completed before v1.0:

\begin{itemize*}
\item Provide a command that typesets the available macros from \emph{all} clients.\\
\url{https://github.com/uliska/luatemplates/issues/28}
\item Add substantial configuration options for the appearance of the documentation.\\
\url{https://github.com/uliska/luatemplates/issues/26}
\item Provide a command to produce documentation as a standalone \texttt{.tex} document.\\
\url{https://github.com/uliska/luatemplates/issues/27}
\end{itemize*}


\section{Defining Formatters}
\label{sec:defining-formatters}

\textbf{TODO:} Use namespace examples already provided in the Lua file

The main task when using \package{luatemplates} is the definition of formatters.
This is essentially divided into two separate areas: declaring string templates
and programming formatter functions.  The templates in themselves are not
inherently more powerful than plain \LaTeX\ macros, but they \emph{do} have
some fine points, and they can be practically used as building blocks in
formatting functions within the Lua domain.

From the perspective of \emph{clients} -- be it Lua code or \LaTeX\ macros --
there is no visible difference between the two, and having them transparently
interchangeable is one of the niceties of working with this package.  The
following sections will go into some detail about how both can be set up.


\subsection{Templates}
\label{sec:templates}

\emph{Templates} in \package{luatemplates} are text strings with zero to nine
\emph{different} replacement fields (corresponding to the number of possible
macro arguments in \LaTeX), while the \emph{same} field can be used multiple
times within a template.  Upon usage the fields are replaced with content from
either a (Lua) function call or a \LaTeX\ macro argument.  Conceptually one can
differentiate between \emph{shorthands}, \emph{styles} and \emph{templates},
based on the number of arguments, although from a technical perspective they are
handled identically.


\subsubsection{Argument Handling}
\label{sec:templates-argument-handling}

\package{luatemplates} tries to infer arguments from formatters as much as
possible to simplify their declarations.  However, with \emph{templates} it is
not always possible to fully automate the process, which is detailed in the
following subsections.

\emph{Replacement fields} are represented through a name surrounded by three
pairs of angled brackets, like e.g. \luavar{<<<title>>>}.  As said, up to nine
different fields can be used within a template, and each of them will be mapped
to one argument of a \LaTeX\ macro.  If a field is used multiple times the
corresponding value is inserted multiple times in the result too. Note that the
mapping of arguments to replacement fields is done \emph{by name} and not
\emph{by order}.  This is crucial because the natural order in which one would
want arguments to be encoded doesn't necessarily have to match the order in
which they appear in the template (one can relate that to traditional \LaTeX\
coding where \texttt{\#1 \#2 \#3} don't necessarily appear in that order in
macros). And -- more importantly -- modifying a template can involve reordering
the occurences of field names. Consider the definition of the \cmd{bookShort}
macro above on page \pageref{fig:bookShort}, requiring the three arguments
\luavar{author}, \luavar{title} and \luavar{year}.  Changing the rendering of
that macro to \texttt{<author> (<year>): <title>} should simply require to
change the template while the order of the macro arguments must be kept
consistent to avoid breaking existing documents.  Therefore templates with more
than one (mandatory) argument must be provided with an array in the
\luavar{args} field of the formatter entry table that specifies the order in
which mandatory arguments are mapped to field names.  See the following sections
for examples.

Technically the names don't matter since they don't have to be used in the
end-user document, but they are used in the self-documentation, so it's always a
good idea to use speaking names, probably using CamelCase to make up for the
missing hyphens.  However, there's one exception to the rule: A field
\luavar{<<<options>>>} will always be mapped to an optional argument.  Since
there is no processing involved (other than with formatter functions, see below)
such a replacement field can only be used in a place where an optional argument
is expected in the resulting macro code.  See the \cmd{image} definition in
\vref{sec:templates-templates} for a working example.  With the \luavar{opt}
field of the formatter entry table a default value for the optional argument can
be specified.


\subsubsection{Shorthands}
\label{sec:shorthands}

\emph{shorthands} are simple strings that are called through a macro, which can
be used to save typing and ensure orthotypographic consistency.  This can be
useful for consistent appearance of, say, abbreviations like
\luaMacroDocInline[demo,nocomment]{BaB}, or an easy handle to specific brands or
other names like \luaMacroDocInline[demo,nocomment]{cary}.%
\footnote{\url{https://www.themorgan.org/music}} %

\begin{minted}{lua}
MY_TEMPLATES = {
    formatters = {
        BaB = [[B\,\&\,B]],
        cary = [[Mary Flagler Cary Music Collection \emph{(Pierpont Morgan Library)}]],
    }
}
\end{minted}


\subsubsection{Styles}
\label{sec:styles}

\emph{styles} are templates with exactly one (mandatory) replacement field,
which will be converted to \LaTeX\ macros with one mandatory argument.  In their
simplest form they work like character styles, applying formatting to some text
(\luaMacroDocInline[demo,nocomment]{textbfit}), but of course they can be used
to add arbitrary visible elements to the content.  This too can be used to
ensure orthotypgraphic consistency, as exemplified in the command \cmd{DV}
(“Deutsch-Verzeichnis”), which on its first level adds a small caps \textsc{d}
and a thin space before the number (\luaMacroDocInline[demo,nocomment,args=911]{DV}).%
\footnote{This will be expanded in \vref{sec:formatter-functions} about formatter
\emph{functions}.}

\begin{minted}{lua}
MY_TEMPLATES = {
    formatters = {
        DV = {
            f = [[\textsc{d}\,<<<dnumber>>>]],
            color = 'cyan',
            comment = 'Deutsch-Verzeichnis',
        },
    }
}
\end{minted}

\noindent But since styles are defined as “macros with one mandatory argument”
their use isn't limited to actual “styles”, and additionally they can make use
of an optional argument.  The following example template shows how that can be
achieved:

\begin{minted}{lua}
MY_TEMPLATES = {
    formatters = {
        image = {
            f = [[\includegraphics[<<<options>>>]{\mediadir/<<<image>>>}]],
            color = 'nocolor',
            opt = 'width=2cm',
        },
    }
}
\end{minted}

\noindent The resulting macro looks like this: \luaMacroDocInline{image}, with
an optional and one mandatory argument.  Since the position of the optional
argument is fixed at \texttt{\#1} the arguments can in this case still be
retrieved automatically without the need for manual configuration. The optional
argument to \cmd{includegraphics} is preset to \luavar{width=2cm}, while the
image name is appended to a media directory path (which is also defined as a
shorthand in the templates table).  \luavar{'nocolor'} is necessary to prevent
the graphics inclusion to be wrapped in a coloring command. So the invocation
\mintinline{tex}{\image{Tux}} would result in an image of width 2\,cm, while the
following forces the height to 1\,\emph{em}:
\luaMacroDocInline[demo,args={height=1em,Tux}]{image}%
\footnote{Image \textcopyright\ \url{lewing@isc.tamu.edu} Larry Ewing and The
GIMP, \url{https://commons.wikimedia.org/w/index.php?curid=80930}}


\subsubsection{Templates}
\label{sec:templates-templates}

\emph{templates} in \package{luatemplates}'s terminology are template strings
with more than one mandatory replacement field.  In order to create \LaTeX\
macros for such templates it is necessary to provide an array with argument
names in the formatter entry table's \luavar{args} field (a failure to do so
will abort the compilation).  This array holds the names of all \emph{mandatory}
arguments in the order they should be used in the macro.  As said this is
necessary to construct the by-name mapping of macro arguments to replacement
fields, therefore the names in the array must match the field names present in
the template. \Vref{fig:template} shows a formatter definition with multiple
mandatory arguments, an optional argument, and an argument occuring twice.
Thanks to the \luavar{args} array this is converted to the macro
\luaMacroDocInline{floatImage}, this time with the options \emph{not} set to a
default value.  Note how the \luavar{<<<image>>>} field is used twice in this
template.  Using the label \luavar{fig:Tux} it is possible to reference the
floating environment (\vref{fig:Tux}).


\begin{figure}
\begin{minted}{lua}
MY_TEMPLATES = {
    floatImage = {
        f = [[
\begin{figure}
\centering
\includegraphics[<<<options>>>]{\mediadir/<<<image>>>}
\caption{<<<caption>>>}
\label{fig:<<<image>>>}
\end{figure}
]],
        args = {'image', 'caption'},
        color = 'nocolor',
    },
}
\end{minted}
\caption{Definition of a template formatter with two mandatory and one optional argument.}
\label{fig:template}
\end{figure}

\luaMacroDoc[demo,args={width=3cm,Tux,A scaled Tux in a floating environment}]{floatImage}



\subsection{Formatter Functions}
\label{sec:formatter-functions}

\emph{Formatter functions} are Lua functions to create parametrical macros of
arbitrary complexity.  They have access to all the templates, other custom
formatters (to make programming more modular) and a number of built-in
formatters assisting in often-used parsing and formatting tasks.  Like with
templates \LaTeX\ macros are automatically created if the formatter is not
explicitly “hidden” through a leading underscore in the formatter name.

Formatter functions are intended for cases where the argument(s) have to be
\emph{processed}, and the limits are really only the imagination and the
capabilities of Lua.  For example the text could be formatted differently
depending on the context (e.g. track progress and color elements alternatingly),
use the argument as a key to something like external database access or an
URL (e.g. insert an image from the web),%
\footnote{See the \package{getmap} package as an example which downloads and
displays map excerpts from OpenStreetMap (\url{https://ctan.org/pkg/getmap})} %
or kick off some algorithmic processing resulting in a diagram presentation etc.

\medskip

Formatter functions are essentially Lua functions that accept a leading
\luavar{self} plus zero to nine additional named arguments and return a
processed string intended to be written back into the \LaTeX\ document.  Note
that the formatter \emph{is given} some data and expected to \emph{return} that
processed string, but \emph{writing back to \LaTeX} is \emph{not} its
responsibility.  This is transparently taken care of by the
\luavar{luatemplates} machinery, which at that stage also controls the optional
coloring.

During the set-up process a formatter function is to some extent modified by
\package{luatemplates}, so it is not anymore a simple method of the
\luavar{<TEMPLATE\_TABLE>.formatters} table where it had been \emph{defined}.
Regardless of whether defined as an independent function or directly as part of
a \emph{formatter entry table} it is wrapped in a
\luavar{Formatter} instance (which is very similar to a formatter entry table).
At this point this is just an aside, and \vref{sec:advanced-programming} will go
into much more detail about the integration of the various objects.  For simple,
self-contained formatter functions there is nothing special to take care of, but
it's important to be aware of the fact that there is some magic going on behind
the scenes and the parent-child or sibling relations are not necessarily as they
seem at definition time.

In this chapter only the basic steps for setting up formatter functions are
discussed while everything else is detailed later.  Assuming the configuration
table is named \luavar{MY\_TEMPLATES}, a simple formatter function may be
created like this:

\begin{minted}{lua}
function MY_TEMPLATES.formatters:foo(text)
    return '|' .. text .. '|'
end
\end{minted}

\noindent This will automatically produce
a \LaTeX\ macro \luaMacroDocInline[demo,args=Foo]{foo} wrapping its argument
text with two pipe symbols, without any further configuration required.


\paragraph{Alternative function definition}

Formatter functions can also be defined directly within the constructor of the
configuration table, which has both up- and downsides.  Consider the following
alternative definition of the same function:

\begin{minted}{lua}
MY_TEMPLATES = {
    ...
    formatters = {
        foo = function(self, text) return '|' .. text .. '|' end,
        baz = ...
    },
}
\end{minted}

\noindent which is functionally the same as the previous one.  Note that the
function receives a leading \luavar{self} argument, which can be achieved
through the colon notation in the standalone version but has to be specified
explicitly in the table constructor version.  However, when the function is
actually \emph{called}, \luavar{self} will refer to the same object.  Within the
function, this will always be the \luavar{Formatter} object holding the
formatter function (\vref{sec:the-formatter-class}), although some
metatable engineering enables wider access to fields from other tables as well.


The major downside to defining functions in the table constructor is that it
tends to become less readable than the “standalone” definition, especially when
functions get more complex.  On the other hand the relations within the
namespace tree become much more obvious this way, and -- this may or may not be
relevant in any given project -- it is possible to directly integrate the
function in the formatter entry table (\vref{fig:inline-function-definition}
shows this in a more deeply nested hierarchy). Again, this is functionally
equivalent to the previous definition style, and I think it's obvious how this
is rather “fragile” in terms of readability but at the same time more explicit.

\begin{figure}
\begin{minted}{lua}
MY_TEMPLATES = {
    ...
    formatters = {
        tools = {
            text = {
                baz = {
                    f = function(self, text)
                        return text .. ' | ' .. text:reverse()
                    end,
                    color = 'red',
                },
                baz = ...
            },
            ...
        },
        ...
    },
    ...
}
\end{minted}
\caption{Integration of a function definition in the table constructor}
\label{fig:inline-function-definition}
\end{figure}

As a final suggestion it is also possible to declare up a formatter entry table in a standalone manner like this:

\setminted[lua]{tabsize=4}

\begin{minted}{lua}
MY_TEMPLATES.formatters.foos.text.baz =  {
	f = function(self, text)
		return text .. ' | ' .. text:reverse()
	end,
	color = 'red'
}
\end{minted}

\noindent but note that for this to work the nested tables
\luavar{MY\_TEMPLATES.formatters.foos.text} must have been created beforehand.

In the end this is a matter of the specific needs of a project and/or personal
preference.



\subsubsection{Argument Handling}
\label{sec:functions-argument-handling}

Like with templates the function arguments have to be mapped to the macro
arguments.  But unlike in templates the \emph{argument order} in functions is well-defined, and \package{luatemplates} can determine this through
introspection.  This means that when writing formatter functions one does
\emph{not} have to take care of naming and ordering of function arguments: a
function with the signature \mintinline{lua}{function foo(text, key, fancy)}
will generate the macro \mintinline{tex}{\foo{text}{key}{fancy}}.  Any
\luavar{args} field in a formatter entry table will simply be ignored.


\subsubsection{Optional argument}
\label{sec:functions-optional-argument}

Also like with templates functions support an \emph{optional argument}, but this
is significantly more powerful than with these.  Whenever a function argument is
named \luavar{options} it will automatically be mapped to a macro's optional
argument.  The function

\begin{minted}{lua}
function MY_TEMPLATES.formatters:reverse(text, options) end
\end{minted}

\noindent will result in a macro \mintinline{tex}{\reverse[options]{text}}. The
\luavar{options} argument can be placed at an arbitrary \emph{position}, but it
seems most natural to put the optional argument at the end of the argument list.
When called from a \LaTeX\ macro this argument will always be a (potentially
empty) string, but when called from Lua functions it may as well be \luavar{nil}
or a table.  In order to deal with this situation a helper function
\mintinline{lua}{self:check_options(options)} can be called, which accepts
strings, tables and \luavar{nil} values, and will always return a (potentially
empty) table.  See the function definition on page \pageref{code:function} for a
working example.

\texttt{key=value} options in an optional argument are processed by courtesy of
\package{lyluatextools}, which mostly gives access to the pairs without further
overhead.   Being sent the optional argument from
\mintinline{tex}{\foo[edition=2,instruments={violin,piano}]},
\mintinline{lua}{self:check_options()} will return a table containing the fields
\mintinline{lua}{{ edition = '2', instruments = 'violin,piano' }}. Optional arguments converted to tables can safely be passed along to other
formatter functions and will then be left untouched by the checker function.  If
like in this case there is a value consisting of mulitple comma-separated values
this intermediate string can be split into an array using the built-in function
\mintinline{lua}{self:split_list()}.  Built-in helper functionality is documented in \vref{sec:builtin-functions}.

\package{lyluatextools} also provides functionality to \emph{validate} options
and optional arguments, both with regard to “known options” and to expected
option types or values.  \package{luatemplates} can make use of that
functionality too, but this requires setting up a dedicated options object for
the document or package, which is described in
\vref{sec:validating-optional-arguments}.


\section{Advanced Formatter Programming}
\label{sec:advanced-programming}

\textbf{TO BE WRITTEN} before a v1.0 release!

The remainder of this manual consists (at this point) of bullet lists and raw material copied over from other places. This chapter has the responsibility to explain in (some) depth what is going on technically with the package, and it aims at giving a more in-depth introduction to idiomatic working with the package.



\subsection{The \LaTeX\ Macro Lifecycle}
\label{sec:latex-macro-lifecycle}

How is a macro generated and what does it actually do when called.

\subsection{Table Structure and Object Relations}
\label{sec:table-structure-object-relations}

\begin{itemize*}
\item What is the overall table structure of \luavar{lua\_templates}
\item What happens during the registration of a formatter
\item How do metatables affect what fields can be seen
\end{itemize*}


.  In particular
it has to be noted that when there are too functions \luavar{foo()} and
\luavar{bar()} defined in the same \luavar{formatters} table \luavar{foo()} can
\emph{not} call \luavar{bar} through \luavar{self:bar()}.  Instead
\luavar{self.bar} (note the dot instead of the colon) will point to the
\luavar{Formatter} object containing the \luavar{bar()} function, and calling
the \luavar{apply()} method of that object will have the desired result:
\mintinline{lua}{self.bar:apply(<args>)}.  This is made possible through some
metatable juggling (see in the chapter referenced above).



The generated \LaTeX\ macros will call the global
\luavar{Template} object's method \luavar{write()}, passing it the formatter's
\luavar{key} and the macro arguments.  \luavar{write()} will then take the
string returned from the formatter and write it back to \LaTeX, optionally
coloring it.




fields of the
\luavar{MY\_TEMPLATES} table, siblings in \luavar{MY\_TEMPLATES.formatters}, and
all fields of the global \luavar{lua\_templates} variable.

Access to sibling formatters is demonstrated in the following \luavar{Bar()} formatter:

\begin{minted}{lua}
function MY_TEMPLATES.formatters:Bar(text)
	 local result = ''
	 for i=1, #text, 1 do
			 result = result .. self.foo:apply(text:sub(i, i))
	 end
	 return result
end
\end{minted}

\noindent This function iterates over the characters in the \luavar{text}
argument and replaces each with the result of calling \luavar{foo()} on it.  The
automatically generated macro could be used like \luaMacroDocInline[demo,args=Foo]{Bar}.

\mintinline{tex}{\bar{abc}},
which would print \textcolor{blue}{|a||b||c|}.


\subsection{The \luavar{Formatter} Class}
\label{sec:the-formatter-class}


\subsection{Validating Optional Arguments}
\label{sec:validating-optional-arguments}

\subsection{Modular Design Principles}
\label{sec:modular-design-principles}

\medskip As formatters have this consistent behaviour of returning a processed
string they can easily be used as building blocks to create a modular library of
code snippets do avoid redundant implementation of formatting code: need an
“n-th edition” superscript as part of various macros or consistent formatting of
email addresses throughout various uses? simply factor them out in
self-contained formatters.  \package{luatemplates} also provides a number of
built-in formatters for this purpose.  For example, wrapping a part of an
element \mintinline{tex}{\emph{}} doesn't have to be coded manually but can be
achieved with \mintinline{lua}{self:format('emph', my_emphasized_word)},
encouraging modular creation of formatters and reducing redundant code.  See
\vref{sec:builtin-formatters} for documentation of the available built-in
formatters.

\subsubsection{Reusing Code}
\label{sec:reusing-code}

\begin{itemize*}
\item Using other formatters from the \emph{same} client
\item Using other (“private”) code from the same client
\item Using formatters from \emph{other} clients
\item Theoretical access to \emph{anything} through \luavar{lua\_templates}
\item Functionality provided by \luavar{Templates}
\label{sec:builtin-functions}
\item Built-in Formatters
\end{itemize*}




\subsubsection{Built-in Formatters}
\label{sec:builtin-formatters}

Use
\checkRange{5-6}
as an example.

\package{luatemplates} implements a substantial number of built-in formatting
functions that can be used from everywhere in the Lua code, especially from
within custom formatting functions, providing an easy way to modularize the
development of formatters.  Technically there are two ways to use a built-in
formatter from a custom formatter function: calling it directly or through
\luavar{self:format()}.  Although slightly less efficient we suggest to always
use the \luavar{format()} approach because it is consistent with the design
principles of the package.  Formatting functions may have an arbitrary number of
arguments -- which are passed through by \luavar{format()} -- and they always
return a processed string.  There are other useful functions defined in the
\luavar{Templates} table which have other return types, but these are documented
in \vref{sec:advanced-programming} -- \emph{formatters} are intended to be used
in \LaTeX\ macros and are therefore guaranteed to return strings.

\medskip

\noindent
The following built-in formatters are available:

\paragraph{\luavar{add\_subscript} / \luavar{add\_superscript} (base, sub/super, parenthesis)}

Add a sub/superscript.

\begin{itemize*}
\item \luavar{base}: The base string to be extended
\item \luavar{sub/super}: The text to be added.\\If this is empty the original
\luavar{base} is returned.
\item \luavar{parenthesis}: If a true value add parentheses around the added text%
\footnote{See \url{https://github.com/uliska/luatemplates/issues/16}}
\end{itemize*}


\paragraph{\luavar{add\_element} (base, element, separator)}

Add an element to a list.

\begin{itemize*}
\item \luavar{base}: The current texte of the list. If this is empty, return
the added element alone.
\item \luavar{element}: The element to be added. If this is empty, return the base
alone.  Otherwise join \luavar{base} and \luavar{element} with \luavar{separator}.
\item \luavar{separator}: Separator between list elements.  If this is missing
use the package option \luavar{element-separator}.
\end{itemize*}


\paragraph{\luavar{bold} (text)}

\paragraph{\luavar{capitalize} (text)}

Make the first letter in the given word/string uppercase.


\paragraph{\luavar{case} (case, text)}

Process the case of the given text.  \luavar{case} is one out of the following
implemented strategies:

\begin{itemize*}
\item \luavar{normal}: Return unmodified
\item \luavar{smallcaps}: Apply small caps
\item \luavar{allsmallcaps}: Convert to lowercase and apply small caps
\item \luavar{upper}: Convert to uppercase
\item \luavar{lower}: Convert to lowercase
\end{itemize*}

More case strategies are intended to be added, see
\url{https://github.com/uliska/luatemplates/issues/2}.

\paragraph{\luavar{emph} (text)}

\paragraph{\luavar{italic} (text)}

\paragraph{\luavar{list\_format} (text, options)}

Format the given text as a \package{biblatex}-like list.  By default the input
is split into a list at the key \texttt{' and '} and returned using the
separators specified by the package options \luavar{list-sep} and
\luavar{list-last-sep}.  These can be overridden by the options
\luavar{input\_separator}, \luavar{separator} and \luavar{last\_separator}.

With the option \luavar{formatter} the key to a formatter can be given that each
list element will be passed through.  The formatter must accept exactly one
mandatory argument, but apart from that both custom and built-in formatters may
be used at will.

\begin{minted}{tex}
\names[formatter=bold]{Haydn and Mozart and Beethoven}
\end{minted}

\noindent will by default return a list “Haydn, Mozart and Beethoven”, where
each of the elements has been formatted with the \luavar{bold} formatter.


\paragraph{\luavar{list\_join} (elements, options)}

Join the list to a string.

By default use the package options \luavar{list-sep} and \luavar{list-last-sep}
as the separators. These can be overridden  by the options \luavar{separator}
and \luavar{last\_separator}.

It is planned to add \package{biblatex}-style list compression too (see
\url{https://github.com/uliska/luatemplates/issues/4}).

\paragraph{\luavar{number} (text, options)}

Format numbers.

If the given text is a number or contains backslashes it is returned unmodified
(having a backslash implies that the whole item is already a formatted
entity). Otherwise it is piped through the \luavar{case} formatter, using either
the package option \luavar{number-case} or the given option of the same name.


\paragraph{\luavar{range} (text, options)}

Formats a (number) range.

Parse and then format a range, with some specific features.  A range is split at
a single hyphen (so \texttt{3--5} would be split into \texttt{3} and
\texttt{-5}).  Then each element is formatted using the \luavar{number}
formatter (with its options).  However, if the second element of the range is
\texttt{f} or \texttt{ff} the value of the package option \luavar{range-follow}
or \luavar{range-ffollow} is used instead, removing the range separator:
%\mintinline{tex}{\range{5-f}}
%will thus produce \range{5-f} and
%\mintinline{tex}{\range[number-case=upper]{xiv-xvii}} comes out as
%\range[number-case=upper]{xiv-xvii}.


\paragraph{\luavar{range\_list} (text, options)}

Format a list of ranges (e.g. for paginations).

Formats a list, using \luavar{range} as the formatter.  Any options are passed
on the the \luavar{list\_format} formatter.  This is a pretty powerful tool for
formatting complex page ranges: text can be inserted like a \package{biblatex}
list field:
\mintinline{tex}{\pages{1 and 5-6 and xiv-ff and
123}}, which will turn out as
\textcolor{blue}{1, \range{5-f}, \range{xiv-ff} and 123}.%
%\footnote{TODO: Fix this once issue \#5 has been fixed. (\pages{1 and 5-6 and xiv-ff and 123}).}


\paragraph{\luavar{wrap\_kv\_option} (key, value)}

Format a \texttt{key=value} option.

If \luavar{value} is given a \value{key=value} pair is returned, otherwise only
the \luavar{key}.  This can be used as a single k/v option somewhere.


\paragraph{\luavar{wrap\_macro} (name, value(s))}

Wrap a value in a macro.

Wrap a single value or a list of values in a \LaTeX\ macro. If \luavar{value} is
a string it is used as a single macro argument, an array list is converted to a
series of arguments. If the string is empty or missing one empty argument is
added to the macro.


\paragraph{\luavar{wrap\_optional\_arg} (opt)}

Wrap an optional argument.

Wrap the given argument in square brackets if one is present, otherwise return
an empty string.


\pagebreak
\section{Examples}
\label{sec:examples}

\subsection{Minimal Working Example}
\label{sec:mwe}

\noindent
\texttt{luatemplates-mwe-templates.lua} and \texttt{luatemplates-mwe.tex}:

\inputminted{lua}{luatemplates-mwe-templates.lua}

\hrule

\inputminted{tex}{examples/luatemplates-mwe.tex}

\pagebreak


\subsection{A Sample Configuration File}
\label{sec:basic-sample-config}

The following listing shows the working configuration file
\texttt{luatemplates-manual-templates.lua} which is actually used for producing
this manual. It is thoroughly commented and aims at being a concise but
comprehensive demonstration of the available tools and options.  In order to
achieve this goal it is obviously less cleanly structured than a real-world file
would be, and it is planned to add further example files demonstrating
particular techniques and approaches.

\inputminted[firstline=11]{lua}{luatemplates-manual-templates.lua}

\enlargethispage*{4\baselineskip}
\end{document}
