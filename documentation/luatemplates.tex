%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is the manual for the luatemplates package.
% Along with the files
% - luatemplates-manual-config.lua
% - luatemplates-manual-config-mwe.lua
% the source itself serves as documentation to the package,
% its use and programming.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% The following includes are general for the writing of this document
%% and not related to the working of luatemplates
\RequirePackage{fontspec}
\RequirePackage{microtype}
\RequirePackage[oldstyle,proportional]{libertine}
\setmonofont[Scale=MatchLowercase,StylisticSet=1]{InconsolataN}
\defaultfontfeatures{
	Ligatures=TeX,
	Scale=MatchLowercase,
	Numbers=Proportional,
	Numbers=OldStyle
}
\frenchspacing
\RequirePackage{graphicx}
\RequirePackage{mdwlist}
\usepackage{varioref}
\usepackage[colorlinks]{hyperref}
\usepackage{cleveref}
%% End general includes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Use or require the `luatemplates` package with (some of the) options
% NOTE: option self-documentation implicitly loads minted, so that doesn't
% have to be included explicitly for the writing of this document.
\usepackage[
color,              % use colors
self-documentation, % Create the self-documentation commands
]{luatemplates}

% Set up the Templates object, passing a variable name prefix
% and a configuration file name.
% The Templates object will later be globally available to Lua by the name
% manual_templates and could be adressed as such from any \directlua command.
% luatemplates-manual-config.lua must be findable by LaTeX.
\setupLuaTemplates{manual}{luatemplates-manual-config.lua}

\title{\package{luatemplates}}
\subtitle{v0.8}
\author{Urs Liska}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}

\package{luatemplates} is a package for Lua\LaTeX\ designed to assist package
and document authors with the recurring task of \emph{templating}.  Essentially
it eliminates the need to deal with the interfacing of the \LaTeX\ and Lua sides
of creating macros.  The package's main objectives are: maintaining  templates
and formatter functions in a central location, easily exposing them as \LaTeX\
macros, and assisting with a modular style of programming templates and styles.

\end{abstract}

\tableofcontents

\section{Introduction}

Templating is one of the most common techniques applied when writing \LaTeX\
packages, especially when Lua is involved which encourages using \LaTeX\ not
only as a \emph{typesetting} but also as a \emph{document/content generation}
system.  Very often one takes some data (from macro arguments), processes it
more or less heavily (ranging from simply \emph{styling} it to taking data as
lookup keys to arbitrarily complex data), and merges it into some kind of
template to produce the final result being written back to the \LaTeX\ document.
When I started to regularly make use of that pattern I realized that in every
case I ended up wanting to concentrate my style and template configuration at a
central place, which usually became a Lua table in a config file.  Following the
DRY paradigm and creating a \emph{package} with support for templating seemed
like a good idea, and watching my configuration and style files shrink to
extraordinary shortness and clarity during the development process was indeed a
pretty inspiring experience.  By now the package allows the definition of
templates and formatter functions in a nearly “declarative” style, while the
corresponding \LaTeX\ macros are generated automatically. Additionally the
package provides tools for and encourages using modular approaches to creating
templates and styles.

This manual is of course written using \package{luatemplates}, and therefore it
is strongly recommended to study the sources too, not only the compiled PDF
file.  Depending on the installation type these may be found in different
places.  If you read this from a \TeX\ Live installation try \texttt{kpsewhich
luatemplates.tex} and \texttt{kpsewhich luatemplates-manual-config.lua} to get
their exact location.  \emph{Basic} and \emph{minimal} working examples are
listed later in this manual (\vref{sec:mwe} and
\vref{sec:basic-sample-config}), and they are also available as files beside
the sources for this manual.%
\footnote{\url{https://github.com/uliska/luatemplates/tree/master/documentation}.\\
\textbf{TODO:} Clarify where they end up in TeX Live.}


\subsection{Dependencies and Installation}
\label{sec:dependencies-and-installation}

The package depends on the \package{lyluatextools} package, which is at this
point only available through the development repository of \package{lyluatex} at
\url{https://github.com/jperon/lyluatex}.  When \package{luatemplates} will be
released to CTAN and eventually hit the \TeX\ distributions we'll make sure the
package releases are in sync.

Installation is done the usual way, by making the package's files
\texttt{luatemplates.sty} and \texttt{luatemplates.lua} available to the
\textsc{texmf} tree. Note that at this point the package can only be used from
the Github development repository at
\url{https://github.com/uliska/luatemplates}.

\textbf{NOTE:} It should go without saying, but better safe than sorry: Since
this package relies heavily on Lua code it can only be compiled with
\package{lualatex}.


\subsection{Basic Concepts}
\label{sec:basic-concepts}

When working with Lua\LaTeX\ to create complex documents or packages the
incentive for using Lua is usually the way of manipulating text and data with
Lua which is both more powerful and more accessible than traditional \LaTeX\
programming.  One common idiom in this context is to get the data from the \TeX\
to the Lua domain as quickly as possible, process it there and only write the
final result back to the \TeX\ document.  However, this can involve significant
overhead that is not always worth the effort and can leave the code in a
confusing mix of \LaTeX\ and Lua.  What I've repeated several times in new
projects is creating an infrastructure to retrieve templating data from a Lua
table and make that available to my \LaTeX\ macros.  The basic idea of this
package is to make this as automatic as possible by providing tools to
\emph{declare} “formatters” (templates and formatter functions) in one Lua table
and have them exposed as \LaTeX\ macros mostly automatically, simply by passing
it to an initialization method. I'll go into more detail soon, but just consider
the following excerpt from a Lua configuration table:

\begin{minted}{lua}
CONFIG = {
    styles = {
        cmd = [[\textbf{\textbackslash <<<name>>>}]]
    }
}
\end{minted}

\noindent which will automatically create a command \luaMacroDocInline{cmd}
with one mandatory argument that can be used in the \LaTeX\ document (and is so
throughout this document) without any further set-up work.  And a Lua function

\label{code:function}
\begin{minted}{lua}
function CONFIG:reverse(text, options)
    options = self:check_options(options)
    if options.smallcaps then
        result = self:wrap_macro('textsc', text:reverse())
    else
        return text:reverse()
    end
end
\end{minted}

\noindent will create a macro \luaMacroDocInline{reverse} with an optional
argument that can be used like

\luaMacroDoc[demo,nocomment,%
demosep=\par\noindent producing ,%
args={smallcaps,The brown fox}]{reverse}%
in the output.  There are four things
to highlight at this point, which are detailed further in the following sections
of the manual:

\begin{itemize*}
\item The handling of optional and mandatory arguments for the \LaTeX\ macro is
done automatically, inferring the details directly from the Lua function's signature.
\item Through the use of \package{lyluatexoptions} handling of optional
\texttt{key=value} arguments has become incredibly simple.  With some more
administrative effort (setting up one's own options instance) their keys and
values can even bevalidated.
\item The package provides helper functions and encourages to go forward with
this approach to follow modular design principles.
\item Output can be colored automatically and conditionally, without having to
hard-code coloring into the macros. This can equally be used to actually create
colored output and to use coloring as a visual checker for correct entry.
\end{itemize*}


\subsection{Minimal Working Example}
\label{sec:mwe}

\Vref{fig:mwe} lists an \textsc{mwe} consisting of one \texttt{.tex} and one
\texttt{.lua} file.

\begin{figure}
\texttt{luatemplates-mwe.tex}:

\inputminted[frame=lines]{tex}{luatemplates-mwe.tex}

\noindent
\texttt{luatemplates-config-mwe.lua}:

\inputminted[frame=lines]{lua}{luatemplates-config-mwe.lua}

\caption{Minimal Working Example setting up three macros in a Lua table}
\label{fig:mwe}
\end{figure}


\section{Usage}
\label{sec:usage}

\subsection{Setting Things Up}
\label{sec:setup}

To use \package{luatemplates} in a document three steps have to be performed,
the first two of them being extremely straightforward. First of all the package
has to be loaded:

\begin{minted}{tex}
\usepackage{luatemplates}
\end{minted}

\noindent There are a number of package options that configure the behaviour,
which will be discussed in \vref{sec:option-handling}.

Once the package is loaded a global variable \luavar{lua\_templates} is
available within any Lua chunks.  This references the “parent” instance of a
\luavar{Templates} table defined in the package.  Usually it is not necessary to
access this object, but it is good to know that it's there.

Now a concrete instance has to be instantiated with

\begin{minted}{tex}
\setupLuaTemplates(<object name prefix>, <config file name>)}
\end{minted}

\noindent After this a global variable \luavar{<object name prefix>\_templates}
will be available to Lua, holding all the information for this particular
instance of \package{luatemplates}. It is also the name by which the package's
auto-generated \LaTeX\ macros operate and access their handlers.  If later on in
this manual “the \luavar{Templates} object” is mentioned it is a reference to
this global variable. \luavar{<config file name>} must refer to a Lua file
returing a single \emph{configuration table} defining the desired structure and
the templates and formatters to be used, its structure and possibilities will be
discussed in \vref{sec:config-table}.

This is all that has to be done on the \LaTeX\ side to set up
\package{luatemplates}.


\subsection{The Config Table}
\label{sec:config-table}

A \emph{configuration table} is a Lua table with a certain structure in which
the behaviour, the interface, and above all the \emph{formatters} are defined
that will be automatically made available as \LaTeX\ macros.%
\footnote{At the time of this writing there can be only \emph{one} such
configuration table, which is passed to the \luavar{Templates} object
as described above.  However, it is intended to support multiple configuration
tables to allow easy composition of an actual set of macros from a choice of
library files.  See \url{https://github.com/uliska/luatemplates/issues/12}
for the state of this development.} %
A \emph{formatter} is either a \emph{template string} or a \emph{Lua function}.
They are transparently called through the generated \LaTeX\ macros which
implicitly call the function \luavar{Templates:format('key', <arguments>)} which
returns a string, and then write the result back the \LaTeX\ document with
optional coloring.  This separation of concerns makes it possible for formatters
to \emph{use} other formatters, encouraging modular or “cascading” approaches to
developing stylesheets. For each (non-hidden) formatter a \LaTeX\ macro is
automatically created, with correct assignment of optional and mandatory
arguments.  If not explicitly specified the macro's name is inferred from the
configuration table structure.

The following subsections describe the mandatory and optional elements that can
be part of the configuration table.


\subsubsection{Configuration}
\label{sec:config-table-configuration}

\paragraph{\luavar{prefix}}

The configuration table can have an optional field \luavar{prefix} which
defaults to an empty string.  This prefix will be given to any generated macro
names and is therefore especially relevant when writing \emph{packages} rather
than using \package{luatemplates} for individual documents.  If this field is set
to \luavar{ltx} for example a macro might be named \cmd{ltxBookName}
instead of \cmd{bookName}.

\begin{minted}{lua}
CONFIG = {
    prefix = 'ltx',
}
\end{minted}


\paragraph{\luavar{namespace}}

If a \luavar{namespace} subtable is provided formatters can be organized in a
hierarchical fashion that will affect both the maintainability of the library
and the resulting macro name namespace. \luavar{namespace} is expected to be a
hierarchical table with no actual entries besides “namespace nodes”.  If no
namespace or an empty table is given then formatters must be organized in a flat
structure -- which may be totally appropriate for smaller projects.%
\footnote{See \url{https://github.com/uliska/luatemplates/issues/13} for planned
changes to the namespace behaviour and the state of development.} %

\begin{minted}{lua}
CONFIG = {
    namespace = {
        literature = {},
        music = {},
    },
}
\end{minted}

\noindent This structure would allow formatters to be stored at table locations
that match the namespace, such as \luavar{publisher}, \luavar{literature.author}
or \luavar{music.composer}, but not \luavar{arts.painter}.  The namespace is
also responsible for the structure of the auto-generated macro names: if not
specified otherwise for a formatter, its macro name is composed as a mixed-case
rendering of the table structure, such as \cmd{publisher},
\cmd{literatureAuthor} or \cmd{musicComposer} (if a prefix is specified the
first element would be capitalized too, like \cmd{ltxLiteratureBook}).


\paragraph{\luavar{configuration}}

A final subtable \luavar{configuration} may be used to either provide additional
configuration data to formatters or to expose built-in formatters to the
creation of \LaTeX\ macros.  More on the configuration data structure of
formatters is detailed in the immediately following section while the process of
generating macros is discussed in \vref{sec:creating-macros}.


\subsubsection{Structure of the Formatter Tables}
\label{sec:structure-of-formatter-tables}

The configuration table may include any or all out of four \emph{formatter
subtables} \luavar{shorthands}, \luavar{styles}, \luavar{templates}, or
\luavar{formatters}.  Their hierarchy has to match that of
the \luavar{namespace} table, but the namespace of each subtable “starts” at its
root, so \luavar{CONFIG.formatters.music.time\_signature} matches the position
of \luavar{CONFIG.namespace.music.time\_signature}.  Any field in a formatter
subtable (or a subtable thereof) that has a match in the \luavar{namespace}
table is considered a “namespace node” while any other field names indicate the
presence of a \emph{formatter}.

Technically the four subtables are interchangeable, and they are actually merged
during the set-up process, but they may be used at will for the organization and
grouping of formatters.   Typically the first three subtables will hold
\emph{template-based} formatters while the last is reserved for
\emph{function-based} formatters, but it is equally possible and valid to just
use \emph{one} subtable and organize the formatters exclusively by their
conceptual hierarchy.


\subsubsection{Formatter Entries}
\label{sec:formatter-entries}

Each leaf in a formatter subtable that is not itself a namespace node holds the declaration of one formatter, which can be coded as one out of:

\begin{itemize*}
\item A (template) string
\item A function (returning a single string)
\item A “formatter entry table”
\end{itemize*}

Template strings and formatter functions are described in \vref{sec:templates}
and \vref{sec:formatter-functions}, and if defined as standalone field values
they are implicitly wrapped in entry tables:

\begin{minted}{lua}
CONFIG = {
    shorthands = {
        LoC = [[Library of Congress]],
    },
    formatters = {
        abbr = function(text) return text:sub(1, 3) .. '.' end,
    }
}
\end{minted}

\noindent will implicitly be understood as:

\begin{minted}{lua}
CONFIG = {
    shorthands = {
        LoC = {
            f = [[Library of Congress]],
        },
    },
    formatters = {
        abbr = {
            f = function(text) return text:sub(1, 3) .. '.' end,
        },
    }
}
\end{minted}

\noindent where the actual formatter (template or function) is recast as the
\luavar{f} field within a \emph{formatter entry table}.

It is recommended to generally use formatter entry tables in all but the most
simple projects because they make the code significantly more explicit,
especially in combination with the self-documenting features described in
\vref{sec:self-documentation}.  For a way to first \emph{declare} the formatter
and then \emph{configure} the details see \vref{sec:configuring-macros}, which
is typically done for formatter functions.

Each formatter whose name (which is defined either by the table key or an
explicit \luavar{name} field) doesn't start with an underscore will implicitly
trigger the creation of a \LaTeX\ macro, for which all available information
(inferred or provided) is used.  See \vref{sec:creating-macros} for details.


\paragraph{Formatter Entry Tables}

The formatter entry table is a flat table with one mandatory and a number of
(conditionally) optional fields:

\paragraph{\luavar{f}}

The mandatory field \luavar{f} (as in \textbf{f}ormatter) holds the actual
formatter, either a template string or a formatter function, as seen just above.


\paragraph{\luavar{name}}

By default the name of the generated \LaTeX\ macro is inferred from the
formatter's position in the table hierarchy, converting the Lua-style dot
notation to a mixed case name.  A formatter stored in \luavar{music.composer}
will produce the macro \cmd{musicComposer} (if no prefix is defined).  With the
\luavar{name} field an explicit name can be specified, circumventing the
automatic name generation.  NOTE (reminder): if the formatter's name resulting
from either its field key or the \luavar{name} field starts with an underscore,
no \LaTeX\ macro will be created for the formatter.


\paragraph{\luavar{comment}}

A \luavar{comment} is generally useful as a visual reminder about what the
formatter is intended to do or represent.  However, beyond its use as a source
code comment it can be used as part of the auto-generated documentation which is
described in \vref{sec:self-documentation}.


\paragraph{\luavar{color}}

With the \luavar{color} field the default color can be overridden, or coloring
can be skipped completely with the option \luavar{'nocolor'}.  See
\vref{sec:coloring} for details of the package's color handling.


\paragraph{\luavar{args}}

An array table \luavar{args} controls the mapping of macro arguments to template
fields in templates with multiple fields.  \luavar{args} is required for
\emph{templates} with more than one mandatory argument and will be ignored for
templates with zero or one mandatory arguments.  It is also ignored for
\emph{formatter functions} whose arguments are completely inferred by
introspection.  See \vref{sec:templates-templates} and
\vref{sec:formatter-functions} for details.


\paragraph{\luavar{opt}}

If the formatter features an optional argument the \luavar{opt} field (if
present and holding a non-empty string) controls the default value that is
provided in the generated \LaTeX\ macro.  See
\vref{sec:templates-argument-handling} and
\vref{sec:functions-argument-handling} for details.

\bigskip

As documented above all but the \luavar{f} fields are optional in most cases,
and you will usually only need a few of them for a reasonably encoded formatter.
The following example shows \emph{all} fields in action, however:

\label{code:bookShort}
\begin{minted}{lua}
CONFIG = {
    {
        book = {
            name = 'bookShort',
            comment = 'A book definition for inline use',
            f = [[\textbf{<<<author>>>}: \emph{<<<title>>>} (<<<year>>>)]],
            color = 'magenta',
            args = {'author', 'title', 'year'},
            -- opt does not make sense here
        }
    }
}
\end{minted}

\noindent
This will implicitly create the macro \luaMacroDocInline{book} with the possible
use\\
\luaMacroDoc[demo,args={Schoenberg,Style and Idea,1950}]{book}.

\medskip

\Vref{sec:basic-sample-config}) lists a complete basic configuration file,
showing the bare minimum code but covering all features.

\subsection{General Techniques}
\label{sec:general-techniques}

There are a few common concepts and general techniques that are worth introducing separately,
although some of the material has to be detailed later.  One of the more
interesting features of the \package{luatemplates} package is the implicit color
handling which simplifies the creation of macros for actually colored documents
or can serve as a handy “draft” tool.  Another important feature is the handling
of macro arguments, which the package can process automatically to a surprising
percentage.  But to start off with, option handling is described.


\subsubsection{Option Handling}
\label{sec:option-handling}

\package{luatemplates} makes use of the option handling features of the
\package{lyluatex} package.%
\footnote{\textbf{NOTE:} Currently it is not clear to what extent these features will
be factored out to an independent package, possibly merged with \package{luatemplates}.
Also it is not clear whether there will be an independent manual for the option handling
tools.} %
This includes the handling of \package{luatemplates}' own package options as
well as providing tools to deal with optional arguments in formatter functions
and created \LaTeX\ macros.  Additionally it is possible to integrate that with
standalone instances of \package{lyluatextools}, which will only be touched in
\vref{sec:advanced-programming}.

\package{luatemplates} has a number of package options which will be described
below.  These can be set upon package loading or at any point during the
document, although not all options may \emph{reasonably} be changed after
loading.  Package options are specified using the \texttt{key=value} syntax, but
boolean values can be set to \texttt{true} by simply passing their name:
\luavar{[color]} is equivalent to \luavar{[color=true]}.

\cmd{luatemplatesSetOption\{key\}\{value\}} can be used to change the value of
an option during the course of the document.  However, depending on the option
this may or may not have any or the desired results, see below for details.
Note that boolean values always have to be given explicitly (other than when set
as package options).

The following package options are available, note that many of them don't affect
the general operation of the package but the behaviour of specific
\emph{built-in formatters} (see \vref{sec:builtin-formatters}).


\paragraph{\luavar{color} (boolean, false)}

If set macros are wrapped in a \cmd{textcolor} macro (if not suppressed through
the macro configuration),  see \vref{sec:coloring} for details about the
coloring concept.  If the option is set as a package option it is checked
whether either the \package{color} or the \package{xcolor} packages are already
loaded, and if neither is, \package{xcolor} is loaded implicitly.

This has the following implication: if \luavar{color} is \emph{not} given as a
package option and no color package has been loaded otherwise it is \emph{not}
possible to set the option to \texttt{true} later in the document.  However, if
a coloring package is loaded (explicitly or implicitly) coloring can be turned
on and off at will throughout the document.

\paragraph{\luavar{default-color} (blue)}

The color used for coloring macros if no other color is specified for a macro or
coloring is switched off for that macro through the pseudo-color
\luavar{'nocolor'}.


\paragraph{\luavar{element-separator} (,)}

Separator to be used in the built-in formatter \luavar{add\_element}.%
\footnote{\textbf{NOTE:} This is affected by
\url{https://github.com/uliska/luatemplates/issues/5}.}


\paragraph{\luavar{number-case} (normal)}

Configuration of the built-in formatter \luavar{number}.  This formatter
provides case handling for consistent appearance of roman numerals (e.g. in
pagination).  Possible values are:

\begin{itemize*}
\item \luavar{normal} (default): leave input unmodified
\item \luavar{smallcaps}: Apply the small caps function
\item \luavar{allsmallcaps}: Convert to lowercase, \emph{then} usd small caps
\item \luavar{upper}: uppercase
\item \luavar{lower}: lowercase
\end{itemize*}

\noindent Note that this will also be applied for \emph{text} if it should
happen to be included in an argument supposedly holding a number.

\paragraph{\luavar{range-follow} / \luavar{range-ffollow} (f. / ff.)}

Text to be used for “f.” or “ff.” (as in “and following”).  Used by the built-in formatter \luavar{range}.


\paragraph{\luavar{range-sep} (\texttt{--})}

Separator used when printing a range.  Used by the built-in formatter \luavar{range}.


\paragraph{\luavar{list-sep} (', ')}

Separator used for all but the last elements of a list produced by the built-in formatter
\luavar{list\_format}.%
\footnote{\textbf{NOTE:} This is affected by
\url{https://github.com/uliska/luatemplates/issues/5}.}


\paragraph{\luavar{list-last-sep} (' and ')}

Separator used for the last two elements of a list produced by the built-in formatter
\luavar{list\_format}.%
\footnote{\textbf{NOTE:} This is affected by
\url{https://github.com/uliska/luatemplates/issues/5}.}


\paragraph{\luavar{self-documentation} (boolean, false)}

If set at package loading this option enables the self-documentation features
described in \vref{sec:self-documentation}.


\subsubsection{Coloring}
\label{sec:coloring}

If the package option \luavar{color} is set to \texttt{true}
\package{luatemplates} supports automatic coloring in various ways.  By default
all macros produced by the package are wrapped in a \cmd{textcolor} macro and
set to the package's \luavar{default-color} option value.  If not set to a
different color (see \vref{sec:option-handling}) this will be \texttt{blue}
(as can be seen throughout most of this manual).  However, if a formatter entry
specifies a different \luavar{color} value this will be used instead of the
package default.  The idea behind this feature is that I really like to use
colors as a visual indicator in “draft” mode to help me make sure the document
is coded properly with the correct semantic markup.  Oftentimes various
different items will end up styled identically, for example with simple emphasis
or boldface.  Assigning different colors to the styles is a visual aide for
proofreading the document, and \package{luatemplates}' approach is a useful tool
to make this technique easily configurable and “switchable”.

Note that if a macro hardcodes a \cmd{textcolor} element in the template itself
it will override the package's handling mechanism, and it will also persist once
the \luavar{color} option is switched off in the package.


\paragraph{\luavar{nocolor}}

If the \luavar{color} field is set to the special value \luavar{'nocolor'} then
the coloring step is skipped completely, so the macro is not set to be black but
not wrapped in \cmd{textcolor} in the first place.  This may be desirable to
have some commands \emph{always} be printed in black, but more importantly it
may be necessary to avoid some macros to break if they can't reasonably be
wrapped in a color -- for example if they produce an environment rather than
simply formatted text.


\subsubsection{Creating Macros}
\label{sec:creating-macros}

One of the main features of this package is the automatic creation of \LaTeX\
macros from formatter declarations.  This section describes how that is done and
what has to be provided.

By default all formatters registered in the configuration table will
automatically produce a corresponding macro, using information that can be
inferred or that has been provided by the formatter entry table.  Macro
arguments are set up appropriately depending on the formatter's type (see
information scattered throughout \vref{sec:defining-formatters}), and the name
is either inferred from the position in the configuration table or by an
explicitly given \luavar{name} field.  For example, if a formatter is located at
\luavar{music.composer.catalogue} its generated macro name would be
\cmd{musicComposerCatalogue}.  If the \luavar{prefix} value is set in the
configuration table this will be used for the generated macro name as well.
However, if the formatter's name starts with an underscore, \emph{no} macro is
created automatically.  This is used to create formatters for internal use by
other formatters that are not intended to be accessible from the \LaTeX\
document.  An example would be a formatter located at \luavar{literature.\_isbn}
or with a \luavar{name} field \luavar{\_load\_metadata}.%
\footnote{Note that after the decision not to create a macro the underscore is
removed, so the formatter will be accessible through its “real” name: \mintinline{lua}{self:format('load_metadata')}, but this will only be relevant in
\vref{sec:formatter-functions}.}

\subsubsection{Configuring Macros}
\label{sec:configuring-macros}

Sometimes it is inconvenient to specify all relevant information in a formatter
entry table directly when registering a formatter.  Most commonly this will
apply to formatter \emph{functions} which typically will be written using Lua's
function definition idiom rather than directly be assigned in a table
constructor (see \vref{sec:formatter-functions}).  For these cases it is
possible to add information to existing formatters in a \luavar{configuration}
subtree of the main configuration table.  This is a flat table whose entries are
very similar to the formatter entry tables described in
\vref{sec:structure-of-formatter-tables}, with some subtle differences described
now.

The \emph{keys} of this table are \emph{macro names}, meaning that a field
\luavar{CONFIG.configuration.bookShort} will configure a \LaTeX\ macro
\cmd{bookShort}.
Each key is associated with a configuration table for a single macro/formatter,
which is located by the mandatory field \luavar{key}.  This is a string
addressing a node in the formatter tree, using Lua-style dot-notation, so
\texttt{bookShort = \{ key = 'literature.book' \}} will cause the formatter at
\luavar{literature.book} to create a macro \cmd{bookShort} instead of
\cmd{literatureBook}.

Since the macro name is now defined through the table's parent field name, and
the formatter is located through the \luavar{key} field, both the \luavar{f} and
the \luavar{name} fields of the formatter entry table are not considered anymore
(technically they are overwritten), apart from this the table's fields  behave
exactly like those in the formatter entry tables describe in
\vref{sec:formatter-entries}.

\begin{minted}{lua}
CONFIG = {
    configuration = {
        revText = {
            key = 'reverse',
            comment = 'Reverse the given string, optionally in small caps.',
            color = 'red',
        }
    }
}
\end{minted}

\noindent
This entry configures a formatter at the toplevel position \luavar{reverse} to
create the macro \cmd{revText} and adds the color and the comment to its
configuration.

\subsubsection{Exposing Built-in Formatters}
\label{sec:exposing-builtin-formatters}

In addition to completing the information for registered formatters the
\luavar{configuration} subtable can also be used to expose built-in formatters
as \LaTeX\ macros. \package{luatemplates} implements a number of built-in
formatter functions that are primarily useful for use by \emph{other} formatters
but also provide convenient end-user macros for general formatting tasks.  Since
they have pretty generic names it didn't seem like a good idea to create macros
for them by default, but this way one can selectively expose them to \LaTeX\
while at the same time exercising control over the macro names.

Since built-in formatters are always \emph{functions} it is not necessary to
provide \luavar{args}, but comments and colors may be useful additions. However,
there is also a shorthand notation by simply assigning the formatter's key to
its intended name.  In this case the built-in formatter is exposed by the given
name without any further configuration:

\begin{minted}{lua}
CONFIG = {
    configuration = {
        names = 'list_format',
    }
}
\end{minted}

\noindent creates the macro \luaMacroDocInline{names}%
\footnote{\textbf{NOTE:} Check this once \#15 has been fixed.}
from the built-in formatter \luavar{list\_format}, correctly assigning the
optional and the mandatory \luavar{text} argument.

Besides being converted to \LaTeX\ macros built-in formatters can be accessed
and used from Lua code.  For details about the use and documentation of
available formatters see \vref{sec:builtin-formatters}.


\subsection{Self-Documentation}
\label{sec:self-documentation}

While it is simple to \emph{declare} formatters and create \LaTeX\ macros from
them it is not always easy to see how they have to be \emph{used} in documents.
This is especially a concern for package writers who are not the consumers of
their own macros.  For that end \package{luatemplates} provides a
self-documentation feature, which is also useful for bug-tracking when generated
macros create errors.

\bigskip

\noindent
\textbf{TO BE WRITTEN} when fully implemented (\#11)



\section{Defining Formatters}
\label{sec:defining-formatters}

The main task when using \package{luatemplates} is the definition of formatters.
This is essentially divided into two separate areas: declaring string templates
and programming formatter functions.  The templates in themselves are not
substantially more powerful than plain \LaTeX\ macros, but they \emph{do} have
some fine points, and they can be practically used as building blocks in
formatting functions.

From the perspective of \emph{clients} -- be it Lua code or \LaTeX\ macros --
there is no visible difference between the two, and having them transparently
interchangeable is one of the niceties of working with this package.  The
following sections will go into some detail about how both can be set up.


\subsection{Templates}
\label{sec:templates}

\emph{Templates} in \package{luatemplates} are text strings with zero to nine
\emph{different} replacement fields (corresponding to the number of possible
macro arguments in \LaTeX), while the \emph{same} field can be used multiple
times within a template.  Upon usage the replacement fields are replaced with
content from either a (Lua) function call or a \LaTeX\ macro argument.
\package{luatemplates}' terminology differentiates between \emph{shorthands},
\emph{styles} and \emph{templates}, based on the number of arguments, although
from a technical perspective they are handled identically. The three
corresponding subtables in the configuration table \emph{may} be used to
organize templates according to their \emph{type}, but it is equally possible to
just use \emph{one} of them, say, \luavar{templates}, and use a namespace below
that to organize templates in a \emph{conceptual} hierarchy.


\subsubsection{Argument Handling}
\label{sec:templates-argument-handling}

\package{luatemplates} tries to infer arguments from formatters as much as
possible to simplify their declarations.  However, with \emph{templates} it is
not always possible to fully automate the process, which is detailed in the
following subsections.

\emph{Replacement fields} are represented through a name surrounded by three
pairs of angled brackets, like e.g. \luavar{<<<title>>>}.  As said, up to nine
different fields can be used within a template, and each of them will be mapped
to one argument of a \LaTeX\ macro.  If a field is used multiple times the
corresponding value is inserted multiple times in the result too. Note that the
mapping of arguments to replacement fields is done \emph{by name} and not
\emph{by order}.  This is crucial because the natural order in which one would
want arguments to be encoded doesn't necessarily have to match the order in
which they appear in the template (one can relate that to traditional \LaTeX\
coding where \texttt{\#1 \#2 \#3} don't necessarily appear in that order in
macros). And -- more importantly -- modifying a template can involve reordering
the occurences of field names. Consider the definition of the \cmd{bookShort}
macro above on page \pageref{code:bookShort}, requiring the three arguments
\luavar{author}, \luavar{title} and \luavar{year}.  Changing the rendering of
that macro to \texttt{<author> (<year>): <title>} should simply require to
change the template while the order of the macro arguments must be kept
consistent to avoid breaking existing documents.  Therefore templates with more
than one (mandatory) argument must be provided with the \luavar{args} array that
specifies the order in which mandatory arguments are mapped to field names.  See
the following sections for examples.

Technically the names don't matter since they don't have to be used in the
end-user document, but they are used in the self-documentation, so it's always a
good idea to use speaking names, probably using CamelCase to make up for the
missing hyphens.  However, there's one exception to the rule: A field
\luavar{<<<options>>>} will always be mapped to an optional argument.  Since
there is no processing involved (other than with formatter functions, see below)
such a replacement field can only be used in a place where an optional argument
is expected in the resulting macro code.  See the \cmd{image} definition in
\vref{sec:templates-templates} for a working example.  With the \luavar{opt}
field of the formatter entry table a default value for the optional argument can
be specified.


\subsubsection{Shorthands}
\label{sec:shorthands}

\emph{shorthands} are simple strings that are called through a macro, which can
be used to save typing and ensure orthotypographic consistency.  This can be
useful for consistent appearance of, say, abbreviations like
\luaMacroDocInline[demo,nocomment]{BaB}, or an easy handle to specific brands or
other names like \luaMacroDocInline[demo,nocomment]{cary}.%
\footnote{\url{https://www.themorgan.org/music}} %

\begin{minted}{lua}
CONFIG = {
    shorthands = {
        BaB = [[B\,\&\,B]],
        cary = [[Mary Flagler Cary Music Collection \emph{(Pierpont Morgan Library)}]],
    }
}
\end{minted}


\subsubsection{Styles}
\label{sec:styles}

\emph{styles} are templates with exactly one (mandatory) replacement field,
which will be converted to \LaTeX\ macros with one mandatory argument.  In their
simplest form they work like character styles, applying formatting to some text
(\luaMacroDocInline[demo,nocomment]{textbfit}), but of course they can be used
to add arbitrary visible elements to the content.  This too can be used to
ensure orthotypgraphic consistency, as exemplified in the command \cmd{DV}
(“Deutsch-Verzeichnis”), which on its first level adds a small caps \textsc{d}
and a thin space before the number
(\luaMacroDocInline[demo,nocomment,args=911]{DV}).%
\footnote{This will be expanded in \vref{sec:formatter-functions} about formatter
\emph{functions}.}

\begin{minted}{lua}
CONFIG = {
    DV = {
        f = [[\textsc{d}\,<<<dnumber>>>]],
        color = 'cyan',
        comment = 'Deutsch-Verzeichnis',
    },
}
\end{minted}

\noindent But since styles are defined as “macros with one mandatory argument”
their use isn't limited to actual “styles”, and additionally they can make use
of an optional argument.  The following example template shows how that can be
achieved:

\begin{minted}{lua}
CONFIG = {
    image = {
        f = [[\includegraphics[<<<options>>>]{\mediadir/<<<image>>>}]],
        color = 'nocolor',
        opt = 'width=2cm',
    },
}
\end{minted}

\noindent The resulting macro looks like this: \luaMacroDocInline{image}, with
the optional argument to \cmd{includegraphics} preset to \luavar{width=2cm},
while the image name is appended to a media directory path (which is also
defined as a shorthand in the configuration table).  \luavar{'nocolor'} is
necessary to prevent the graphics inclusion to be wrapped in a coloring command.
So the invocation \mintinline{tex}{\image{Tux}} would result in an image of
width 2\,cm, while the following forces the height to 1\,\emph{em}:
\luaMacroDocInline[demo,args={height=1em,Tux}]{image}%
\footnote{Image \textcopyright\ \url{lewing@isc.tamu.edu} Larry Ewing and The GIMP,
\url{https://commons.wikimedia.org/w/index.php?curid=80930}}


\subsubsection{Templates}
\label{sec:templates-templates}

\emph{templates} in \package{luatemplates}'s terminology are template strings
with more than one mandatory replacement field.  In order to create \LaTeX\
macros for such templates it is necessary to provide an \luavar{args} array in
the formatter entry table (a failure to do so will abort the compilation).  This
array holds the names of all \emph{mandatory} arguments in the order they should
be used in the macro.  As said this is necessary to construct the by-name
mapping of macro arguments to replacement fields, therefore the names in the
array must match the field names present in the template. \Vref{fig:template}
shows a formatter definition with multiple mandatory arguments, an optional
argument, and an argument occuring twice.

\begin{figure}
\begin{minted}{lua}
CONFIG = {
    floatImage = {
        f = [[
\begin{figure}
\centering
\includegraphics[<<<options>>>]{\mediadir/<<<image>>>}
\caption{<<<caption>>>}
\label{fig:<<<image>>>}
\end{figure}
]],
        args = {'image', 'caption'},
        color = 'nocolor',
    },
}
\end{minted}
\caption{Definition of a template formatter with two mandatory and one optional argument.}
\label{fig:template}
\end{figure}

\noindent Thanks to the \luavar{args} array this is converted to the macro
\luaMacroDocInline{floatImage}, this time with the options \emph{not} set to a
default value.  Note how the \luavar{<<<image>>>} field is used twice in this
template.  Using the label \luavar{fig:Tux} it is possible to reference the
floating environment (\vref{fig:Tux}).

\luaMacroDoc[demo,args={width=3cm,Tux,A scaled Tux}]{floatImage}



\subsection{Formatter Functions}
\label{sec:formatter-functions}

\emph{formatters} are Lua functions to create parametrical macros of arbitrary
complexity.  Formatting functions have access to all the templates, other custom
formatters (to make programming more modular) and a number of built-in
formatters assisting in often-used parsing and formatting tasks.  Like with
templates \LaTeX\ macros are automatically created if not explicitly hidden
through a leading underscore in the formatter name.

Formatting functions are intended for cases where the argument(s) have to be
\emph{processed}, and the limits are really only the imagination and the
capabilities of Lua.  For example the text could be formatted differently
depending on the context (e.g. track progress and color elements alternatingly)
or use the argument as a key to something like external database access or an
URL (e.g. insert an image from the web).%
\footnote{See the \package{getmap} package as an example which downloads and
displays map excerpts from OpenStreetMap (\url{https://ctan.org/pkg/getmap})}

\medskip

A formatter function is essentially a method of the \luavar{Templates} object
taking an arbitrary number of arguments and returning a processed string
intended to be written back into the \LaTeX\ document.  Note that the formatter
\emph{is given} some data and expected to \emph{return} that processed string,
but \emph{writing back to \LaTeX} is \emph{not} its responsibility.  The regular
process is that the macros generated by \package{luatemplates} call the object's
\luavar{write()} method, which will then call a formatter function and write the
result back to \LaTeX, taking care of conditionally wrapping the result in
coloring code.

Assuming the configuration table is named \luavar{CONFIG}, a simple formatter
function may be created like this:

\begin{minted}{lua}
function CONFIG.formatters:foo(text)
    return '|' .. text .. '|'
end
\end{minted}

\noindent Without any further work this will automatically produce a \LaTeX\
macro \mintinline{tex}{\foo{text}} that encloses its argument with two pipe
symbols.  As indicated by the colon notation the formatter will receive a first
\luavar{self} argument, which will always reference the \luavar{Templates}
instance created in \mintinline{tex}{\setupLuaTemplates}, the object referenced
by the global variable -- e.g in the case of this manual
\luavar{manual\_templates}.  Through this -- the global variable or
\luavar{self} -- any elements of the \luavar{Templates} table defined in the
package and added in the configuration table can be called, including our function
\luavar{foo()}.

For the following definition of the formatter \luavar{bar()} it is assumed that
the \emph{namespace} (see \vref{sec:structure-of-formatter-tables}) allows a key
\luavar{'tools.text'}:

\begin{minted}{lua}
function CONFIG.formatters.tools.text:bar(text)
    local result = ''
    for i=1, #text, 1 do
        result = result .. self:format('foo', text:sub(i, i))
    end
    return result
end
\end{minted}

\noindent This function iterates over the characters in the \luavar{text}
argument and replaces each with the result of calling \luavar{foo()} on it.  The
automatically generated macro could be used like \mintinline{tex}{\bar{abc}},
which would print \textcolor{blue}{|a||b||c|}.

\medskip As formatters have this consistent behaviour of returning a processed
string they can easily be used as building blocks to create a modular library of
code snippets do avoid redundant implementation of formatting code: need an
“n-th edition” superscript as part of various macros or consistent formatting of
email addresses throughout various uses? simply factor them out in
self-contained formatters.  \package{luatemplates} also provides a number of
built-in formatters for this purpose.  For example, wrapping a part of an
element \mintinline{tex}{\emph{}} doesn't have to be coded manually but can be
achieved with \mintinline{lua}{self:format('emph', my_emphasized_word)},
encouraging modular creation of formatters and reducing redundant code.  See
\vref{sec:builtin-formatters} for documentation of the available built-in
formatters.


\paragraph{Function definition in the configuration table}

Formatter functions can also be defined directly in the constructor of the
configuration table, which has both up- and downsides.  Consider the following
excerpt from a config table:

\begin{minted}{lua}
CONFIG = {
    ...
    formatters = {
        foo = function(self, text) return '|' .. text .. '|' end,
        baz = ...
    },
}
\end{minted}

\noindent which is functionally the same as the previous definition.  Note that
since we don't have access to the colon notation here the \luavar{self} argument
has to be specified explicitly.  However, when the function is actually
\emph{called}, \luavar{self} will refer to the exactly same object.

The major downside to this way of defining functions is that it tends to become
less readable than the “standalone” definition, especially when functions get
more complex.  On the other hand the relations within the namespace tree become
much more obvious this way, and -- this may or may not be relevant in any given
project -- it is possible to directly integrate the function in the formatter
entry table (\vref{inline-function-definition}).
Again, this is functionally equivalent to the previous definition, and
I think it's obvious how this style is rather “fragile” in terms of readability
but at the same time more explicit.  In the end this is a matter of the specific
needs of a project and/or personal preference.

\begin{figure}
\begin{minted}{lua}
CONFIG = {
    ...
    formatters = {
        tools = {
            text = {
                bar = {
                    f = function(self, text)
                        local result = ''
                        for i=1, #text, 1 do
                            result = result .. self:format('foo', text:sub(i, i))
                        end
                        return result
                    end,
                    color = 'red',
                },
                baz = ...
            },
            ...
        },
        ...
    },
    ...
}
\end{minted}
\caption{Integration of a function definition in the table constructor}
\label{inline-function-definition}
\end{figure}


\subsubsection{Argument Handling}
\label{sec:functions-argument-handling}

Like with templates the function arguments have to be mapped to the macro
arguments. But unlike templates the functions have their arguments in a defined
\emph{order}, and \package{luatemplates} can determine this through
introspection.  This means that when writing formatter functions one does
\emph{not} have to take care of naming and ordering of function arguments: a
function with the signature \mintinline{lua}{function foo(text, key, fancy)}
will generate the macro \mintinline{tex}{\foo{text}{key}{fancy}}.  Any
\luavar{args} field in a formatter entry table will simply be ignored.


\subsubsection{Optional argument}
\label{sec:functions-optional-argument}

Also like with templates functions support an \emph{optional argument}, but this
is significantly more powerful than with these.  Whenever a function argument is
named \luavar{options} it will automatically be mapped to a macro's optional
argument.  The function

\begin{minted}{lua}
function CONFIG.formatters:reverse(text, options) end
\end{minted}

\noindent will result in a macro \mintinline{tex}{\reverse[options]{text}}. This
works regardless of the \emph{position} of the optional argument in the Lua
function's signature, but it seems most natural to put the optional argument at
the end of the argument list.  When called from a \LaTeX\ macro this argument
will always be a (potentially empty) string, but when called from other
functions it may as well be \luavar{nil} or a table.  In order to deal with this
situation a helper function \mintinline{lua}{self:check_options(options)} can be
called, which accepts strings, tables and \luavar{nil} and always returns a
(potentially empty) table.  See the function definition on page
\pageref{code:function} to see it in action.

\texttt{key=value} options in an optional argument are processed by courtesy of
\package{lyluatextools}, which mostly gives access to the pairs without further
overhead.  The data from an optional argument
\mintinline{tex}{\foo[edition=2,instruments={violin,piano}]} will be processed
to a table containing the fields \mintinline{lua}{{ edition = '2', instruments =
'violin,piano' }} if being sent to \mintinline{lua}{self:check_options()}.
Optional arguments converted to tables can safely be passed along to other
formatter functions and will then be left untouched by the checker function.  If
like in this case there is a value consisting of mulitple comma-separated values
this intermediate string can be split into an array using the built-in function
\mintinline{lua}{self:split_list()}.  There are multiple helper functions
implemented in \package{luatemplates} that are not considered “built-in
formatters” because they don't return a single string (that could be used in a
\LaTeX\ macro), but these are documented later in
\vref{sec:advanced-programming}.


\subsubsection{Built-in Formatters}
\label{sec:builtin-formatters}

\package{luatemplates} implements a substantial number of built-in formatting
functions that can be used from everywhere in the Lua code, especially from
within custom formatting functions, providing an easy way to modularize the
development of formatters.  Technically there are two ways to use a built-in
formatter from a custom formatter function: calling it directly or through
\luavar{self:format()}.  Although slightly less efficient we suggest to always
use the \luavar{format()} approach because it is consistent with the design
principles of the package.  Formatting functions may have an arbitrary number of
arguments -- which are passed through by \luavar{format()} -- and they always
return a processed string.  There are other useful functions defined in the
\luavar{Templates} table which have other return types, but these are documented
in \vref{sec:advanced-programming} -- \emph{formatters} are intended to be used
in \LaTeX\ macros and are therefore guaranteed to return strings.

\medskip

\noindent
The following built-in formatters are available:

\paragraph{\luavar{add\_subscript} / \luavar{add\_superscript} (base, sub/super, parenthesis)}

Add a sub/superscript.

\begin{itemize*}
\item \luavar{base}: The base string to be extended
\item \luavar{sub/super}: The text to be added.\\If this is empty the original
\luavar{base} is returned.
\item \luavar{parenthesis}: If a true value add parentheses around the added text%
\footnote{See \url{https://github.com/uliska/luatemplates/issues/16}}
\end{itemize*}


\paragraph{\luavar{add\_element} (base, element, separator)}

Add an element to a list.

\begin{itemize*}
\item \luavar{base}: The current texte of the list. If this is empty, return
the added element alone.
\item \luavar{element}: The element to be added. If this is empty, return the base
alone.  Otherwise join \luavar{base} and \luavar{element} with \luavar{separator}.
\item \luavar{separator}: Separator between list elements.  If this is missing
use the package option \luavar{element-separator}.
\end{itemize*}


\paragraph{\luavar{bold} (text)}

\paragraph{\luavar{capitalize} (text)}

Make the first letter in the given word/string uppercase.


\paragraph{\luavar{case} (case, text)}

Process the case of the given text.  \luavar{case} is one out of the following
implemented strategies:

\begin{itemize*}
\item \luavar{normal}: Return unmodified
\item \luavar{smallcaps}: Apply small caps
\item \luavar{allsmallcaps}: Convert to lowercase and apply small caps
\item \luavar{upper}: Convert to uppercase
\item \luavar{lower}: Convert to lowercase
\end{itemize*}

More case strategies are intended to be added, see
\url{https://github.com/uliska/luatemplates/issues/2}.

\paragraph{\luavar{emph} (text)}

\paragraph{\luavar{italic} (text)}

\paragraph{\luavar{list\_format} (text, options)}

Format the given text as a \package{biblatex}-like list.  By default the input
is split into a list at the key \texttt{' and '} and returned using the
separators specified by the package options \luavar{list-sep} and
\luavar{list-last-sep}.  These can be overridden by the options
\luavar{input\_separator}, \luavar{separator} and \luavar{last\_separator}.

With the option \luavar{formatter} the key to a formatter can be given that each
list element will be passed through.  The formatter must accept exactly one
mandatory argument, but apart from that both custom and built-in formatters may
be used at will.

\begin{minted}{tex}
\names[formatter=bold]{Haydn and Mozart and Beethoven}
\end{minted}

\noindent will by default return a list “Haydn, Mozart and Beethoven”, where
each of the elements has been formatted with the \luavar{bold} formatter.


\paragraph{\luavar{list\_join} (elements, options)}

Join the list to a string.

By default use the package options \luavar{list-sep} and \luavar{list-last-sep}
as the separators. These can be overridden  by the options \luavar{separator}
and \luavar{last\_separator}.

It is planned to add \package{biblatex}-style list compression too (see
\url{https://github.com/uliska/luatemplates/issues/4}).


\paragraph{\luavar{number} (text, options)}

Format numbers.

If the given text is a number or contains backslashes it is returned unmodified
(having a backslash implies that the whole item is already a formatted
entity). Otherwise it is piped through the \luavar{case} formatter, using either
the package option \luavar{number-case} or the given option of the same name.


\paragraph{\luavar{range} (text, options)}

Formats a (number) range.

Parse and then format a range, with some specific features.  A range is split at
a single hyphen (so \texttt{3--5} would be split into \texttt{3} and
\texttt{-5}).  Then each element is formatted using the \luavar{number}
formatter (with its options).  However, if the second element of the range is
\texttt{f} or \texttt{ff} the value of the package option \luavar{range-follow}
or \luavar{range-ffollow} is used instead, removing the range separator:
\mintinline{tex}{\range{5-f}} will thus produce \range{5-f} and
\mintinline{tex}{\range[number-case=upper]{xiv-xvii}} comes out as
\range[number-case=upper]{xiv-xvii}.


\paragraph{\luavar{range\_list} (text, options)}

Format a list of ranges (e.g. for paginations).

Formats a list, using \luavar{range} as the formatter.  Any options are passed
on the the \luavar{list\_format} formatter.  This is a pretty powerful tool for
formatting complex page ranges: text can be inserted like a \package{biblatex}
list field: \mintinline{tex}{\pages{1 and 5-6 and xiv-ff and
123}}, which will turn out as \textcolor{blue}{1, \range{5-f}, \range{xiv-ff} and 123}.%
\footnote{TODO: Fix this once issue \#5 has been fixed. (\pages{1 and 5-6 and xiv-ff and 123}).}


\paragraph{\luavar{wrap\_kv\_option} (key, value)}

Format a \texttt{key=value} option.

If \luavar{value} is given a \value{key=value} pair is returned, otherwise only
the \luavar{key}.  This can be used as a single k/v option somewhere.


\paragraph{\luavar{wrap\_macro} (name, value(s))}

Wrap a value in a macro.

Wrap a single value or a list of values in a \LaTeX\ macro. If \luavar{value} is
a string it is used as a single macro argument, an array list is converted to a
series of arguments. If the string is empty or missing one empty argument is
added to the macro.


\paragraph{\luavar{wrap\_optional\_arg} (opt)}

Wrap an optional argument.

Wrap the given argument in square brackets if one is present, otherwise return
an empty string.




\section{Advanced Formatter Programming}
\label{sec:advanced-programming}

Give some indications about more advanced techniques for writing formatter functions. Some topics include:

\begin{itemize*}
\item Examples of “cascading” and modular strategies
\item Documenting the useful methods in \luavar{Templates}
\item \luavar{Templates:write()}, \luavar{Templates:format} and friends
\end{itemize*}

TO BE WRITTEN before a v1.0 release!

\pagebreak
\section{A Basic Sample Configuration File}
\label{sec:basic-sample-config}

The following listing shows one working configuration file (reduced from the
actual file used for this manual). It is very sparsely commented in order not to
reduce clarity, and it aims at providing just the minimal material necessary to
show all options.

\inputminted{lua}{luatemplates-config-basic.lua}

\end{document}
