
% This is the manual for the luaformatters package.
% Along with the files
% - luaformatters-manual-templates.lua
% - examples/*.lua and examples/*.tex
% - luaformatters-manual-config-mwe.lua
% the source itself serves as documentation to the package,
% its use and programming.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{scrartcl}
\usepackage{luaformattersmanual}

% Use or require the `luaformatters` package with (some of the) options
% NOTE: option self-documentation implicitly loads minted, so that doesn't
% have to be included explicitly for the writing of this document.
\usepackage[
color,              % use colors
self-documentation, % Create the self-documentation commands
]{luaformatters}

% Set up the Formatters object, passing a configuration file name.
% The Formatters object will later be globally available to Lua by the name
% manual_templates and could be adressed as such from any \directlua command.
% luaformatters-manual-config.lua must be findable by LaTeX.
\addLuaFormatters{luaformatters-manual}

% The formatters are organized in a modular fashion, distributed over several
% declaration files.  The purpose in *this document* is to be able to list
% the following files separately at the end of the manual, but it also shows
% an approach that can be used for other purposes of modular organization.
\addLuaFormatters{examples/luaformatters-mwe.lua}
\addLuaFormatters{examples/luaformatters-closure}
\addLuaFormatters{examples/luaformatters-format}
\addLuaFormatters{examples/luaformatters-local-formatters.lua}
\addLuaFormatters{examples/luaformatters-additionals}


\title{\luaformatters}
\subtitle{v0.8}
\author{Urs Liska}
\date{\HEADdate}

\begin{document}

\maketitle

\begin{abstract}

\luaformatters\ is a package for Lua\LaTeX\ assisting package (and document)
authors bridging the gap between the \LaTeX\ and the Lua domains.  It allows to
declare and program “formatters” completely in Lua files and have the
corresponding \LaTeX\ macros be generated automatically.  This reduces the
complexity of writing Lua-based packages and encourages (and simplifies) code
reuse and a modular programming style.

\end{abstract}

%\bigskip
\hrule

\bigskip

\noindent \NOTE{Disclaimer:} This version of the manual is written for the
initial v0.8 release and -- although quite comprehensive -- in a \emph{very}
preliminary state. This particularly includes the overall structure, which is
overly redundant and going in loops. While it is intentional to touch the
subjects more than once at distinct degrees of depth, the structure has suffered
from the manual having been written in parallel with the package development:
writing documentation triggered changes and restructuring of the code base,
which in turn required changes to the documentation.

A full revision of the manual is planned preceding the release of v1.0 beta. The
issue list requests a number of potentially fundamental enhancements and
modifications until that point, and it seems reasonable to delay decisions about
a better manual outline until the interface and functionality have settled to a
final state.  See \url{https://github.com/uliska/luaformatters/issues/37} for
the current state of this discussion.

\medskip

\noindent \NOTE{Disclaimer 2:} This package has been renamed from
\package{luatemplates} to \luaformatters\ shortly before the initial release
because it has become clear that \emph{formatters} are the actual concern and
perspective of the package.  However, it is possible or even likely that there
are remnants of the original name and concept scattered throughout the manual,
the example files, and maybe even the code itself.  This will be fully ironed
out by the release v1.0, but for now if you encounter anything that is
surprisingly named anything related to “templates” it has probably been
overlooked in the translation process.

\newpage

\tableofcontents

\section{Introduction}

\enlargethispage*{\baselineskip}

One of the most common tasks when writing \LaTeX\ packages%
\footnote{This includes packages written for a single document or for public
	release.} %
is the creation of new macros that perform some sort of \emph{styling} or other
\emph{processing} of input text or data. Styles can be visually conceived (e.g.
\mintinline{tex}{\shaded{highlighted text}}) or semantically
(\mintinline{tex}{\historicPerson{Goethe}}), but macros can also perform complex
operations like generating a table row from a macro like
\mintinline{tex}{\EAN[quantity=15,price=12.95]{0075678164125}}.  Especially the
latter can benefit very much from Lua\LaTeX\ that allows writing arbitrarily
complex functionality in Lua, which for many is much more accessible than \TeX\
programming and which can turn \LaTeX\ from a document \emph{typesetting engine}
into a \emph{document generating system}.

\luaformatters\ simplifies a programming pattern that aims at doing as much work
as possible in the Lua domain and as little as possible in \LaTeX.  The
traditional approach for using Lua functionality is creating a macro in \LaTeX,
passing arguments to a Lua function which then writes the result back to \LaTeX.
The \LaTeX\ macro serves as a mere \emph{interface} to the Lua code i this
arrangement. While this works and is very flexible it can be cumbersome to
handle the passing of data from \LaTeX\ to Lua and back over and over again for
every macro, leading to redundant and somewhat cluttered code. With
\luaformatters\ a “formatter” can be declared and/or programmed completely in
Lua -- as a simple string template or an arbitrarily complex Lua function --
while \luaformatters\ takes care of generating the \LaTeX\ macro, handles
passing the arguments (including sophisticated handling of optional arguments)
to Lua and writing the results back to \LaTeX.

\begin{quote}

--- This \LaTeX\ document:

\inputminted{tex}{examples/luaformatters-mwe.tex}

\noindent --- and this \luavar{luaformatters-mwe.lua} file:

\inputminted{lua}{examples/luaformatters-mwe.lua}

\end{quote}

\noindent are enough to create two macros \luaMacroDocInline[demo,args=red]{red}
and \luaMacroDocInline[demo,args={reverse,Reverse}]{optReverse} to be usable in
a document.  For more examples see \vref{sec:examples}.  They are also available
for closer inspection in the \texttt{documentation} and
\texttt{documentation/examples} subdirectories of the development repository%
\footnote{\url{https://github.com/lualatex-tools/luaformatters/tree/master/documentation}} %
or the CTAN package.%
\footnote{\url{http://ctan.org/pkg/luaformatters}}

\subsection{Dependencies and Installation}
\label{sec:intro:dependencies-and-installation}

\luaformatters\ depends on the \package{luaoptions} package%
\footnote{\url{https://github.com/lualatex-tools/luaoptions}} %
and implicitly on a few standard packages that should be generally available.
We will make sure that CTAN releases of \luaformatters\ and \package{luaoptions}
are in sync, but if you intend to use \luaformatters\ from its Github repository
you should generally do so with \package{luaoptions} as well.

Installation is done the usual way, by making the package's files
(\texttt{luaformatters.sty} and \texttt{luaformatters.lua} and the
\texttt{submodules} folder) available to the \textsc{texmf} tree.  It is
strongly advised to place the package(s) below \texttt{<texmf>/tex/luatex} (not
\texttt{latex}) in order to be found before a possible \TeX\ Live installation.

\NOTE{NOTE:} It should go without saying, but better safe than sorry: Since
this package relies heavily on Lua code it can only be compiled with
\package{lualatex}.


\subsection{(Package) Options}
\label{sec:intro:options}

\luaformatters\ makes use of the option handling features of the
\package{lyluatex} package.%
\footnote{\textbf{NOTE:} Currently it is not clear to what extent these features will
	be factored out to an independent package, possibly merged with \luaformatters.
	Also it is not clear whether there will be an independent manual for the option handling
	tools.} %
This includes the handling of \luaformatters' own package options as
well as providing tools to deal with optional arguments in formatter functions
and created \LaTeX\ macros.  Additionally it is possible to integrate that with
standalone instances of \package{luaoptions}, which will only be touched in
\vref{sec:advanced-programming}.

\luaformatters\ has a number of package options which will be described
below.  These can be set upon package loading or at any point during the
document, although not all options may \emph{reasonably} be changed after
loading.  Package options are specified using the \texttt{key=value} syntax, but
boolean values can be set to \texttt{true} by simply passing their name:
\luavar{[color]} is equivalent to \luavar{[color=true]}.

\cmd{setluaoption\{formatters\}\{key\}\{value\}} can be used to change the value
of an option during the course of the document.  However, depending on the
option this may or may not have any or the desired results, see below for
details. Note that boolean values always have to be given explicitly (other than
when set as package options).

The following package options are available, note that many of them don't affect
the general operation of the package but the behaviour of specific
\emph{built-in formatters} (see \vref{sec:defining:builtin-formatters}).


\paragraph{\luavar{color} (boolean, false)}

If set macros are wrapped in a \cmd{textcolor} macro (if not suppressed through
the macro configuration),  see \vref{sec:coloring} for details about the
coloring concept.  If the option is set as a package option it is checked
whether either the \package{color} or the \package{xcolor} packages are already
loaded, and if neither is, \package{xcolor} is loaded implicitly.

This has the following implication: if \luavar{color} is \emph{not} given as a
package option and no color package has been loaded otherwise it is \emph{not}
possible to set the option to \texttt{true} later in the document.  However, if
a coloring package is loaded (explicitly or implicitly) coloring can be turned
on and off at will throughout the document.

\paragraph{\luavar{default-color} (blue)}

The color used for coloring macros if no other color is specified for a macro or
coloring is switched off for that macro through the pseudo-color
\luavar{'nocolor'}.


\paragraph{\luavar{element-separator} (,)}

Separator to be used in the built-in formatter \luavar{add\_element}.


\paragraph{\luavar{number-case} (normal)}

Configuration of the built-in formatter \luavar{number}.  This formatter
provides case handling for consistent appearance of roman numerals (e.g. in
pagination).  Possible values are:

\begin{itemize*}
	\item \luavar{normal} (default): leave input unmodified
	\item \luavar{smallcaps}: Apply the small caps function
	\item \luavar{allsmallcaps}: Convert to lowercase, \emph{then} usd small caps
	\item \luavar{upper}: uppercase
	\item \luavar{lower}: lowercase
\end{itemize*}

\noindent Note that this will also be applied for \emph{text} if it should
happen to be included in an argument supposedly holding a number.

\paragraph{\luavar{range-follow} / \luavar{range-ffollow} (f. / ff.)}

Text to be used for “f.” or “ff.” (as in “and following”).  Used by the built-in formatter \luavar{range}.


\paragraph{\luavar{range-sep} (\texttt{--})}

Separator used when printing a range.  Used by the built-in formatter \luavar{range}.


\paragraph{\luavar{list-sep} (', ')}

Separator used for all but the last elements of a list produced by the built-in
formatter \luavar{list\_format}.


\paragraph{\luavar{list-last-sep} (' and ')}

Separator used for the last two elements of a list produced by the built-in formatter
\luavar{list\_format}.


\paragraph{\luavar{self-documentation} (boolean, false)}

If set at package loading this option enables the self-documentation features
described in \vref{sec:self-documentation}.


\subsection{General Concepts}
\label{sec:intro:general-concepts}

There are a few common concepts and general techniques that are worth introducing separately,
although some of the material has to be detailed later.  One of the more
interesting features of the \luaformatters\ package is the implicit color
handling which simplifies the creation of macros for actually colored documents
or can serve as a handy “draft” tool.  Another important feature is the handling
of macro arguments, which the package can process automatically to a surprising
percentage.  But to start off with, option handling is described.



\subsubsection{Coloring}
\label{sec:coloring}

If the package option \luavar{color} is set to \texttt{true}
\luaformatters\ supports automatic coloring in various ways.  By default
all macros produced by the package are wrapped in a \cmd{textcolor} macro and
set to the package's \luavar{default-color} option value.  If not set to a
different color (see \vref{sec:intro:options}) this will be \texttt{blue}
(as can be seen throughout most of this manual).  However, if a formatter entry
specifies a different \luavar{color} value this will be used instead of the
package default.  The idea behind this feature is that I really like to use
colors as a visual indicator in “draft” mode to help me make sure the document
is coded properly with the correct semantic markup.  Oftentimes various
different items will end up styled identically, for example with simple emphasis
or boldface.  Assigning different colors to the styles is a visual aide for
proofreading the document, and \luaformatters' approach is a useful tool
to make this technique easily configurable and “switchable”.

Note that if a macro hardcodes a \cmd{textcolor} element in the template itself
it will override the package's handling mechanism, and it will also persist once
the \luavar{color} option is switched off in the package.


\paragraph{\luavar{nocolor}}

If the \luavar{color} field is set to the special value \luavar{'nocolor'} then
the coloring step is skipped completely, so the macro is not set to be black but
not wrapped in \cmd{textcolor} in the first place.  This may be desirable to
have some commands \emph{always} be printed in black, but more importantly it
may be necessary to avoid some macros to break if they can't reasonably be
wrapped in a color -- for example if they produce an environment rather than
simply formatted text.


\subsubsection{Self-Documentation}
\label{sec:self-documentation}

While it is simple to \emph{declare} formatters and create \LaTeX\ macros from
them it is not always easy to see how they have to be \emph{used} in documents.
This is especially a concern for package writers who are not the consumers of
their own macros (well, actually it's more a problem for the \emph{users} of a
package who are not the \emph{authors} of the macros \dots).  To help with that
situation \luaformatters\ provides a self-documentation feature, which is
also useful for bug-tracking. When the package is loaded with the
\luavar{self-documentation} package option set, two things happen: “docstrings”
are generated for each formatter, and a number of \LaTeX\ macros to typeset the
documentation are created.

\medskip

\noindent \textbf{NOTE:} self-documentation is powered by \package{minted}, with
the following implications:

\begin{itemize*}
	\item The \package{minted} \LaTeX\ package has to be installed.
	\item \package{Pygments} has to be available and configured (see the \package{minted} manual for details).
	\item \LaTeX\ has to be started with the \texttt{--shell-escape} option to
	allow the start of external programs (Pygments, a Python program).  Please make
	sure that you understand the security implications of this decision.
	\item Note that this applies to compiling this manual as well.
\end{itemize*}

\paragraph{General options}

The self-documenting macros are governed by a number of options that apply to
all types of documentation string (if not mentioned otherwise).

\begin{itemize}
	\item \luavar{args}\\
	By default the docstring prints the argument \emph{names} as specified in the
	template or function.  But if \luavar{args} is provided as a comma-separated
	list (wrappped in curly brackets) the values are used to replace the argument
	names.  Note that this is not a \texttt{key=value} table but a list of arguments
	that are used in order of appearance.
	\item \luavar{demo}\\
	By default just a documentation string of the macro is typeset.  If the
	\luavar{demo} option is given, then additionally an \emph{example} of the macro
	use is given.
	\item \luavar{demosep}\\
	If a usage demo is printed it is separated from the documentation string by a
	separator that is specific to the command used for the documentation (described
	below).  However, if \luavar{demosep} is given as an option it is used instead.
	\item \luavar{nocomment}\\
	If this option is set a comment stored with the formatter is not printed.
\end{itemize}

\paragraph{\mintinline{tex}{\luaMacroDocInline[options]{command}}}

This command produces documentation for a single macro and inserts it at the
current position (i.e. within the current paragraph).  An available comment in
the formatter will be ignored, so the \luavar{nocomment} options doesn't have
any effect with this command.

\begin{itemize}
	\item \mintinline{tex}{\luaMacroDocInline{reverse}}\\
	produces \luaMacroDocInline{reverse}, documenting the macro name and its
	arguments.  Here the argument names specified in the template or function are
	used, so that's an incentive to use well-decided names.
	\item \mintinline{tex}{\luaMacroDocInline[args={smallcaps,The brown fox}]{reverse}}\\
	produces \luaMacroDocInline[args={smallcaps,The brown fox}]{reverse}, inserting
	the provided arguments to give a usage example.
	\item \mintinline{tex}{\luaMacroDocInline[demo,args={smallcaps,The brown fox}]{reverse}}\\
	produces \luaMacroDocInline[demo,args={smallcaps,The brown fox}]{reverse},
	adding a \emph{typeset} rendering of the command. (Note that this may be
	particularly useful for debugging purposes.)
	\item \mintinline{tex}{\luaMacroDocInline[demo,demosep={ => },args={smallcaps,The brown fox}]{reverse}}\\
	produces \luaMacroDocInline[demo,demosep={ => },args={smallcaps,The brown fox}]{reverse}, replacing the default colon with a custom separator between docstring and result.
\end{itemize}


\paragraph{\mintinline{tex}{\luaMacroDoc[options]{command}}}

This command produces documentation for a single macro and inserts it wrapped in a \luavar{minted} environment.  If one is available a formatter comment is displayed too.

\medskip
\noindent \mintinline{tex}{\luaMacroDoc{reverse}} --\\
provides the default documentation for the command:

\luaMacroDoc{reverse}

\medskip
\noindent \mintinline{tex}{\luaMacroDoc[nocomment]{reverse}} --\\
provides the default documentation for the command, but without the comment:

\luaMacroDoc[nocomment]{reverse}

\medskip
\noindent \mintinline{tex}{\luaMacroDoc[args={smallcaps,The brown fox}]{reverse}} --\\
uses the given argument values:

\luaMacroDoc[args={smallcaps,The brown fox}]{reverse}

\medskip
\noindent \mintinline{tex}{\luaMacroDoc[demo,args={smallcaps,The brown fox}]{reverse}} --\\
uses the given argument values and adds a demo in a new paragraph:

\luaMacroDoc[demo,args={smallcaps,The brown fox}]{reverse}

\medskip
\noindent \mintinline{tex}{\luaMacroDoc[demo,demosep={\par\hrule\par\bigskip\noindent},args={smallcaps,The brown fox}]{reverse}} --\\
additionally specifies a custom separator:

\luaMacroDoc[demo,demosep={\par\hrule\par\bigskip\noindent},args={smallcaps,The brown fox}]{reverse}


\paragraph{\mintinline{tex}{\luaMacroDocClient[options]{client-name}}}

produces a sorted list of macro documentations for a given “client”.  As there seems no reasonable way to do it the \luavar{demo} (and related) options have no effect on this command.  The same is true for the \luavar{args} option.
Configuration of the appearance is currently on the wishlist \dots

\medskip

\noindent \mintinline{tex}{\luaMacroDocClient[nocomment]{manual}} produces the
list of macros defined in this manual's template table (some of them are created
for \emph{use} in the manual, others for demonstrating purposes).  Leaving out
the \luavar{nocomment} option would add the comments for formatters that have
one defined. (The output is wrapped in a \texttt{quote} environment for better clarity):

\begin{quote}
	\luaMacroDocClient[nocomment]{manual}
\end{quote}

\bigskip

\hrule

\bigskip

\noindent \textbf{TODO:} There are a few open ends and functionality that has to be completed before v1.0:

\begin{itemize*}
	\item Provide a command that typesets the available macros from \emph{all} clients.\\
	\url{https://github.com/uliska/luaformatters/issues/28}
	\item Add substantial configuration options for the appearance of the documentation.\\
	\url{https://github.com/uliska/luaformatters/issues/26}
	\item Provide a command to produce documentation as a standalone \texttt{.tex} document.\\
	\url{https://github.com/uliska/luaformatters/issues/27}
\end{itemize*}


\subsection{A Walkthrough}
\label{sec:intro:walkthrough}

The final part of the introduction gives a bird's eye view on the process of
setting up a \luaformatters-powered \term{Formatter Library}.  It walks through
all the necessary steps, introducing the terminology used in the package, and
referring to later sections with more in-depth explanations.

\subsubsection{Setting Up the \LaTeX\ Document}
\label{sec:intro:walkthrough:latex-document}

The first step setting up a document for use with \luaformatters\ is to load the
package with or without adding the package options described in
\vref{sec:intro:options}:

\begin{minted}{tex}
\usepackage[options]{luaformatters}
% or
\RequirePackage[options]{luaformatters}
\end{minted}

\noindent The second step is to \emph{add} a \term{Client}
(\vref{sec:intro:walkthrough:the-client}) to the \term{Formatter Library} using
the macro

\begin{minted}{tex}
\addLuaFormatters{<lua-file>}
\end{minted}

\noindent with \luavar{<lua-file>} referring to the Lua module where the
\term{Client} has been defined.  Note that this Lua module can be found either
as relative to the current working directory or through Lua\LaTeX's search path.
This means that if your files \emph{are} in the search path (e.g. when writing
a package rather than merely a single document) their filenames must be unique
across the \LaTeX\ distribution in order to avoid name clashes.

\medskip

\noindent That's all that has to be done on the \LaTeX\ side \dots


\subsubsection{The Formatter Library}
\label{sec:intro:walkthrough:formatter-library}

The \term{Formatter Library} is a global Lua table -- \luavar{Formatters},
defined in \texttt{luaformatters.lua} -- that provides general functionality for
handling the library.  It manages an arbitrary number of \term[Client]{Clients}
as described in the next section.  Its functionality is described throughout the
manual when applicable,%
\footnote{Detailed documentation can be found in
\vref{sec:advanced:the-lua-templates-object}.} %
and it is generally referred to as “the Formatter Library” or “the
\luavar{Formatters} table”.

The \luavar{Formatters} table is instantiated automatically upon loading the
package and stored in a global Lua variable \luavar{lua\_formatters}, which from
an author's perspective is mainly used for instantiating new \term{Client}
objects.  Usually the table is not called explicitly but accessed through the
\luavar{self:} accessor of the objects that are edited.


\subsubsection{The Client(s)}
\label{sec:intro:walkthrough:the-client}

Each package that wants to make use of \luaformatters\ has to create and
register (at least) one \term{Client} object, which is an instance of the
\luavar{FormattersTable} class, typically in one Lua file per client.  Such an
instance is created with the factory function
\luavar{lua\_formatters:new\_client()} and returned as the result of the module,
which in its simplest form looks like:

\begin{minted}{lua}
local MANUAL = lua_formatters:new_client('manual')
...
return MANUAL
\end{minted}

\noindent Throughout the manual \luavar{MANUAL} is used as the name of the local
variable the \luavar{FormattersTable} object is stored in.  Passing a string as
the client's name (which has to be unique across all clients that could possibly
be loaded in a single document) as the single argument is the simplest form of
instantiating a \term{Client}, more on the initialization options is detailed in
\vref{sec:usage:initializing-the-template-table}.

Multiple \term[Client]{Clients} can be added to the \term{Formatters Library},
for example when multiple packages using \luaformatters\ are loaded, or
explicitly to compose the final \term{Formatters Library} in a modular fashion.%
\footnote{\NOTE{TODO:} Currently there is no consistent handling of name clashes
between multiple \term[Client]{Clients} or their contents.  Elements from
clients which are added later will silently overwrite previous declarations,
possibly breaking documents. This has to be resolved, see
\url{https://github.com/uliska/luaformatters/issues/24}.} %
The library used for this manual makes use of this feature too: the
functionality has been split into several modules which can independently serve
as examples and are listed in the manual to show certain techniques and
possibilities (\vref{sec:examples}). Stripped off the comments the relevant
section in the manual's \texttt{.tex} file \texttt{luaformatters.tex} looks like
this:

\begin{minted}{tex}
\addLuaFormatters{luaformatters-manual.lua}
\addLuaFormatters{examples/luaformatters-closure.lua}
\addLuaFormatters{examples/luaformatters-format.lua}
\addLuaFormatters{examples/luaformatters-local-formatters.lua}
\addLuaFormatters{examples/luaformatters-additionals.lua}
\end{minted}


\subsubsection{Formatters}
\label{sec:intro:walkthrough:formatters}

The main task of a package author is populating the \term{Formatters Table} with
\term[Formatter]{Formatters} and configure them so that later -- when the table
returned from the file is registered in the library through
\mintinline{tex}{\addLuaFormatters} --\LaTeX\ macros can automatically be
created from them. The term \term{Formatter} is somewhat ambiguous in
\luaformatters's terminology, and it is important to understand the subtle
difference between the involved concepts.


\paragraph{Formatters}
\label{sec:intro:walkthrough:formatters}

In a narrow sense a \term{Formatter} is either a \emph{string template} or a
\emph{Lua function} with zero to nine replacement fields or named arguments,
returning a processed string as the result.  The task of a \term{Formatter} is
very specific and limited to this processing step -- handling macro arguments
(including the optional one) and writing the results back to \LaTeX\ is
transparently handled by the package. This separation of concerns is the
foundation for the modular programming style encouraged and simplified by
\luaformatters.  The basics of writing formatters are detailed in
\vref{sec:usage:string-templates} (string templates) and
\vref{sec:usage:formatter-functions} (Lua functions), while
\vref{sec:advanced-programming} goes into further depth about programming
techniques for Lua functions.


\paragraph{Formatter Entry Tables}
\label{sec:intro:walkthrough:formatter-entry-tables}

Each \term{Formatter} that is to be stored in a \term{Formatters Table} is --
either explicitly or implicitly -- wrapped in a \term{Formatter Entry Table},
which is a Lua table containing both the formatter itself and configuration
metadata further specifying how the formatter will be used to create a \LaTeX\
macro.  Details about the declaration of formatters and \term[Formatter Entry
Table]{Formatter Entry Tables} are outlined in
\vref{sec:usage:declaring-formatters}.


\paragraph{Formatter Objects}
\label{sec:intro:walkthrough:formatter-objects}

When finally in use as part of a \LaTeX\ macro the \term{Formatter Entry Table}
will have been converted to a \term{Formatter Object}, that is, an instance of
the \luavar{Formatter} class.  This conversion is done transparently during the
regitsration of a \term{Client} in the \term{Formatters Library}, and the
package author does not need to take care about it.  The \luavar{Formatter}
class (defined in \texttt{submodules/luaformatters-formatter.lua}) is one of
\luaformatters' workhorses and documented in detail in
\vref{sec:advanced:the-formatter-class}.


\paragraph{Regular, Hidden, and Local Formatters}
\label{sec:intro:walkthrough:regular-hidden-local-formatters}

By default \luaformatters\ will create \LaTeX\ macros from all registered
\term[Formatter]{Formatters}, but it is also possible to configure formatters to
be \emph{hidden} (\vref{sec:usage:hidden-formatters}) or \emph{local}
(\vref{sec:usage:adding-local-formatters}).

\term[Hidden Formatter]{Hidden Formatters} are formatters from which no macros
are created but that are nevertheless usable from other (Lua) formatters, even
from other \term[Client]{Clients} (\vref{sec:advanced:modular:formatters}).

\term[Local Formatter]{Local Formatters} are like hidden formatters, but they
are even more restricted in so far as they can only be used by Lua functions
from \emph{the same} \term{Client}
(\vref{sec:advanced:modular:local-formatters}).


\subsubsection{Macros}
\label{sec:intro:walkthrough:macros}

From each formatter that is not marked as hidden a
\LaTeX\ macro is created which later \emph{uses} the formatter to process the
macro's arguments and optionally apply coloring to the result. This separation
of concerns makes it possible for formatters to \emph{use} other formatters
entirely in the Lua domain, encouraging modular or “cascading” approaches to
developing stylesheets. If not explicitly specified the macro's name is inferred
from the configuration table structure.


\paragraph{Configuring Formatters}
\label{sec:intro:walkthrough:configuring-formatters}

For various reasons it may be necessary to add properties to a \term{Formatter} separately from its declaration, for example to make the original declaration simpler, or to enable some kind of modular and/or automatic generation.  This process is detailed in \vref{sec:usage:configuring-formatters}.


\paragraph{Publishing Built-in Formatters}
\label{sec:intro:walkthrough:publishing-builtin-formatters}

\luaformatters\ provides a large number of \term[Built-in Formatter]{Built-in
Formatters} that can be used from custom formatters to design style libraries in
modular fashion.  Most of these formatters are rather generic and are therefore
hidden by default to prevent the macro namespace from being polluted with macros
not requested explicitly.  However, through the configuration process the
built-in formatters can be published as \LaTeX\ macros too.  See
\vref{sec:usage:publishing-builtin-formatters} for details.  Through the same
process formatters declared as hidden in \emph{other} packages may be published
as \LaTeX\ macros too.




\section{Usage}
\label{sec:usage}

The main task of a package author using \luaformatters\ is creating and
maintaining a \term{Formatters Table}, which is described in this section of the
manual.  Its focus is the handling of the template and the functionality
\luaformatters\ provides to work with the table, while the specifics of
writing formatters will be covered in the next main section.  This section will
necessarily present formatters as examples, but without going in too much detail
about the topic.  It is always possible to jump back and forth between the
“table” and the “formatters” sections, if it seems necessary for the
understanding.

If not stated otherwise everything in the following sections refers to the work
in the Lua file whose name is passed to \mintinline{tex}{\addLuaFormatters{}}.

\subsection{The Formatters Table}
\label{sec:usage:templates-table}

In order to be registered as a \term{Client} a table must be an instance of the
\luavar{FormattersTable} class and eventually returned as a module.  Such an object is instantiated by calling the factory
function \mintinline{lua}{lua_formatters:new_client()}.  In its most basic form this would look like this:

\begin{minted}{lua}
local MANUAL = lua_formatters:new_client('manual')
-- defining the contents of the Formatters Table
return MANUAL
\end{minted}

\noindent When the argument to \mintinline{lua}{lua_formatters:new_client()} is a string
this is taken as the \term{Template Table}'s name.  This name must be unique
across all \term[Client]{Clients} that are loaded in the current document, which
should especially be a concern for \emph{package} authors while the issue seems
less serious when related to single documents.


\subsection{Initializing the Formatters Table}
\label{sec:usage:initializing-the-template-table}

Typically it is better to pass a \emph{table} to the factory method instead of
merely a string, which gives extended configuration options or even the
possibility to directly add content. The only mandatory field such a table must
have is \luavar{name}, and the following invocation is equivalent to the
previous example:

\begin{minted}{lua}
local MANUAL = lua_formatters:new_client{
	name = 'manual'
}
\end{minted}

\noindent The table passed to the factory function can have certain optional
fields that can be used to configure the \term{Formatters Table} during the
instantiation. Other than with the \emph{content} elements (formatters) there
are no provisions to alter these configuration options at a later point.

\subsubsection[Macro Name Prefix]{\luavar{prefix} -- Macro Name Prefix}

If the configuration table includes the \luavar{prefix} field with a string this
will be prepended to any generated macro names, which is especially relevant
when writing \emph{packages}.  If this field is set to \luavar{ltx} a macro
would for example be named \cmd{ltxBookName} instead of \cmd{bookName}.

\begin{minted}{lua}
local MANUAL = lua_formatters:new_client{
	name = 'manual',
	prefix = 'ltx',
}
\end{minted}


\subsubsection[Display Name]{\luavar{display\_name} -- Display Name}

A templates table can have an optional field \luavar{display\_name} which if
missing defaults to the \luavar{name} value.  Currently this field is not
actively supported, but it is intended to be used in the self-documentation
features (\vref{sec:self-documentation}).

\begin{minted}{lua}
local MANUAL = lua_formatters:new_client{
	name = 'manual',
	display_name = 'luaformatters Manual',
}
\end{minted}

\subsubsection[Enforcing Namespaces]{\luavar{strict}, \luavar{namespace} -- Enforcing Namespaces}

Formatters are stored in a potentially nested Lua table that implicitly creates
a \term{Namespace}, both for the structure of the code and the naming
conventions of the generated \LaTeX\ macros. By default it is only possible to
add formatters to \emph{existing} nodes that have previously been created, be it
through generic Lua means or through \luaformatters' tools
(\vref{sec:usage:declaring-formatters})  However, if the \luavar{strict} field
is included and set to \texttt{false} this limitation is removed, and the
commands that add formatters to the table can automatically create missing table
nodes. Note that this can be at the same time convenient, especially for complex
namespaces, but it can also lead to unnoticed typos.

\begin{minted}{lua}
local MANUAL = lua_formatters:new_client{
	name = 'manual',
	strict = false,
}
\end{minted}

\noindent If a \luavar{namespace} field is present in the configuration table
then the provided namespace is created -- which is only meaningful when the
\luavar{strict} option is \emph{not} set to \texttt{false}.  The value of the
field is either a single string or an array of strings, each specifying a “key”
in Lua-style dot notation:

\begin{minted}{lua}
local MANUAL = lua_formatters:new_client{
	name = 'manual',
	namespace = 'music.composer',
	-- or
	namespace = {
		'music.composer',
		'music.work',
		'music.locations',
	},
}
\end{minted}

\noindent Setting up a namespace is also possible outside of the factory function, by calling the \mintinline{lua}{provide_namespace()} function of the \term{Template Table}:

\begin{minted}{lua}
MANUAL:provide_namespace{
	'literature.author',
	'literature.book',
	'literature.publisher',
}
\end{minted}

\noindent This function \emph{adds} to the existing namespace, so it is possible
to use it multiple times (if that is deemed good for the organization of the
material), regardless of whether a namespace has been initialized in the factory
function.

After these examples it would be possible to add formatters at
\luavar{music.composer.name} or \luavar{literature.publisher.location}, but not
\luavar{theater.city}.

\subsubsection[Content]{\luavar{formatters}, \luavar{\_local}, \luavar{configuration} -- Content}

In addition to the \emph{configuration} options documented above it is also
possible to add one or more of three “content” subtables, \luavar{formatters},
\luavar{\_local} and \luavar{configuration}.  The \luavar{formatters} subtable
holds regular formtters, \luavar{\_local} local formatters, and
\luavar{configuration} additional configuration entries. While there are no
serious arguments to be made against this approach it is not exactly recommended
for general use, because it somewhat goes against the idea of \luaformatters.
But it should not be omitted that it is perfectly \emph{possible} to prepare a
complete configuration table and pass it to the factory function with the sole
purpose of converting it to a \luavar{FormattersTable} instance. In fact it is
possible to finish the configuration file with something like

\begin{minted}{lua}
return lua_formatters:new_client(MANUAL)
\end{minted}

\noindent in which case a manually composed table \luavar{MANUAL} would only at
the last moment be converted to a \luavar{FormattersTable}.  This is perfectly
valid, but the syntactic sugar helping the maintenance of the table is not
available that way.


\subsection{Registering the Client}
\label{sec:usage-registering-the-client}

As was briefly mentioned in the introduction the \term{Template Table} has to be
registered as a \term{Client} to the \term{Formatters Library}.  At that point
all the declared formatters are processed and the \LaTeX\ macros created.  The
“canonical” way of doing this is to have the configuration file return the
\luavar{FormattersTable} instance and passing that file's name/path  to the
\LaTeX\ macro \mintinline{tex}{\addLuaFormatters{<filename>}}.

But the same can actually be achieved while staying in the Lua domain.
Internally the \LaTeX\ macro calls \luavar{lua\_formatters:add()}, and this can
equally be done explicitly from the Lua file.  Assuming \luavar{MANUAL} being a
valid \luavar{FormattersTable} instance

\begin{minted}{lua}
lua_formatters:add(MANUAL)
\end{minted}

\noindent at the end of the file would also register the \luavar{MANUAL} table
with the main templating system.  In this case it would be irrelevant whether
the Lua file returns anything because the registration is already complete.  (In
fact this is exactly how the built-in formatters are added to the library.) If a
package should provide a modular set of \term[Template Table]{Template Tables},
for example in response to package options or depending on whether some other
packages have been loaded, it isn't necessary to add these in \LaTeX\ (or even
through \emph{writing} the \LaTeX\ invocation back).


\subsection{Declaring Formatters}
\label{sec:usage:declaring-formatters}

\subsubsection{Adding Formatters}
\label{sec:usage-adding-formatters}

Formatters are \emph{declared} (or \emph{added}) by storing a \term{Formatter
Entry} (\vref{sec:usage:formatter-entries}) somewhere in the hierarchy of the
\term{Formatters Table}'s \luavar{formatter} subtable.

\begin{minted}{lua}
MANUAL = {
	...
	formatters = {
		-- formatters are stored here
	}
}
\end{minted}

\noindent While this can be done manually \luaformatters\ provides two methods to
simplify the process and to improve readability of the configuration files:
\mintinline{lua}{add_formatter(key, formatter)} and
\mintinline{lua}{add_formatters(...)}.  For details about writing formatters
please refer to \vref{sec:defining-formatters} and
\vref{sec:advanced-programming}.


\paragraph{\luavar{add\_formatter}}

This function declares a \emph{single} formatter at the position \luavar{key},
which is a path in Lua-style dot-notation, entered as a string.  If the parent
node of the given key does not exist yet it is either silently created (along
with any intermediate nodes that are also missing), or an error is triggered and
the compilation aborted, depending on the \luavar{strict} option described in
the previous section. The formatter can be given as a \term{Formatter Entry} in
any of the forms described in \vref{sec:usage:formatter-entries}:

\begin{minted}{lua}
MANUAL:add_formatter('music.composer.century', [[(Ct: <<<century>>>)]])
\end{minted}

\paragraph{\luavar{add\_formatters}}

This function declares \emph{multiple} formatters in the same position of the
namespace.  It can be used in three different ways, depending on the given
arguments: zero, one or two strings, with a mandatory table in the last
position.

If \emph{one} string is given it is simply ignored and considered a
\emph{comment}. The idea behind this uncommon behaviour is to use this function
as a means of structuring the configuration file and adding formatters in
semantically coherent \emph{groups}.

If \emph{two} strings are given the second string specifies the namespace
\emph{key} below which the new formatters should be added.  As before, the
behaviour in case of a key that doesn't yet exist is controlled by the
\luavar{strict} option.  If a second string is \emph{not} given (or no string
argument at all) the formatters are added to the top level.

The final argument is a -- possibly nested -- table specifying multiple
formatters.

\begin{minted}{lua}
MANUAL:add_formatters{
	foo = [[:::<<<xyz>>>:::]],
	bar = [[\_\_<<<abc>>>\_\_]]
}

MANUAL:add_formatters('Vehicles', {
	car = [[\textit{<<<type>>>}]],
	bicycle = [[\textbf{<<<bike>>>}]]
})

MANUAL:add_formatters('Composers', 'music.composers, '{
	name = [[\emph{<<<name>>>}]],
	style = [[[(\textsc{<<<style>>>})]]]
})
\end{minted}


\paragraph{Standalone function declaration}

\emph{Lua Functions} can be added with the two functions described above as
well, but often it is more practical to use Lua's regular “standalone” syntax to
define them.  It is possible to add functions in the \luavar{formatters}
subtable of the \term{Formatters Table}:

\begin{minted}{lua}
function MANUAL.formatters.music.composers:abbr_name(text)
	if #text > 3 then text = text:sub(1, 3) .. '...' end
    return text
end
\end{minted}

\noindent However, note that it is necessary that the parent node
(\luavar{(formatters.)music.composers} in this example) already exists.  Also,
this way none of the additional fields of a \term{Formatter Entry Table} can be
set directly and would have to be provided through explicit configuration later.


\subsubsection{Adding Local Formatters}
\label{sec:usage:adding-local-formatters}

A second type of formatters are \term[Local Formatter]{Local Formatters}.  These
are mostly identical to ordinary formatters with the exception that they are
only available for use within the current client, and that they are never
accessible to \LaTeX\ macros.

Local formatters are added with the functions
\luavar{lua\_formatters:add\_local\_formatter()} and \luavar{lua\_formatters:add\_local\_formatters()}
that apart from registering the formatters to a different storage location
behave identically to the functions described in the previous section.

Local formatter functions can be defined with the standalone syntax as well,
only that instead of the \luavar{formatters} subtable they have to be located
within \luavar{\_local}.  They can be equally nested, and the behaviour regarding
the namespace is identical to regular formatters.


\subsubsection{Formatter Entries}
\label{sec:usage:formatter-entries}

Each leaf in the \luavar{formatters} subtable of the \term{Formatters Table}
holds the declaration of one \term{Formatter}, a \term{Formatter Entry}.  This
can be coded as:

\begin{itemize*}
\item a (template) string,
\item a function (returning a single string), or
\item a proper \term{Formatter Entry Table}
\end{itemize*}

Standalone templates or functions will be implicitly wrapped in basic
\term[Formatter Entry Table]{Formatter Entry Tables}, as described in the next
section. For a way to first \emph{declare} the formatter and then
\emph{configure} the details see \vref{sec:usage:configuring-formatters}, which
is typically done for formatter functions that are defined using the regular
function definition syntax rather than being directly assigned in the table
constructor.


\subsubsection{Formatter Entry Tables}
\label{sec:usage-formatter-entry-tables}

The general recommendation is to declare formatters using a \term{Formatter
Entry Table} in all but the most simple projects because these make the code
more explicit, especially in combination with the self-documenting features
described in \vref{sec:self-documentation}.

The formatter entry table is a flat table with a number of allowed fields.  At
least one out of \luavar{template} and \luavar{func} must be present.

\paragraph{\luavar{template}}

The string template to be used for the formatter.  If no function is declared in
addition the template will be used and the fields replaced with values.

\begin{minted}{lua}
MANUAL:add_formatter('LoC', {
	template = [[Library of Congress]]
})
\end{minted}


\paragraph{\luavar{func}}

A function can be stored as well.  If present it will be called automatically to
apply the formatter.

\begin{minted}{lua}
MANUAL:add_formatter('reverse', {
	func= function(self, text) return text:reverse() end,
})
\end{minted}

\noindent If both a function and a template are declared the function will
always be called, but the function can access the template with
\luavar{self:template()} and process it with \luavar{self:replace()}.  If only a
string or a function is used as the value of a formatter it will implicitly be
wrapped and saved in the correct field.


\paragraph{\luavar{name}}

When a \LaTeX\ macro is created from a formatter (\vref{sec:creating-macros}) its name is by default inferred from the
formatter's position in the table hierarchy, converting the Lua-style dot
notation to a mixed case name.  A formatter stored in \luavar{music.composer}
will produce the macro \cmd{musicComposer} (if no prefix is defined).  With the
\luavar{name} field an explicit macro name can be specified, circumventing the
automatic name generation.

\begin{minted}{lua}
MANUAL:add_formatter('music.composers.abbr_name', {
	-- f = ... ,
	name = 'abbrName',
})
\end{minted}

\noindent will create the macro \cmd{abbrName} instead of \cmd{musicComposersAbbrName}.

NOTE: if the formatter's name resulting from either its field key or the
\luavar{name} field starts with an underscore, no \LaTeX\ macro will be created
for the formatter (\vref{sec:usage:hidden-formatters}).


\paragraph{\luavar{comment}}

A \luavar{comment} is generally useful as a visual reminder about what the
formatter is intended to do or represent.  However, beyond its use as a source
code comment it can be used as part of the auto-generated documentation which is
described in \vref{sec:self-documentation}.

\begin{minted}{lua}
MANUAL:add_formatter('music.composers.abbr_name', {
	-- f = ... ,
	comment = "Abbreviate a composer's name (if > 3 characters)",
})
\end{minted}


\paragraph{\luavar{color}}

With the \luavar{color} field the default color can be overridden, or coloring
can be skipped completely with the option \luavar{'nocolor'}.  See
\vref{sec:coloring} for details of the package's color handling.

\begin{minted}{lua}
MANUAL:add_formatter('music.composers.abbr_name', {
	-- f = ... ,
	color = 'red', -- or 'nocolor'
})
\end{minted}


\paragraph{\luavar{args}}

An array table \luavar{args} controls the mapping of macro arguments to template
fields in templates with multiple fields.  \luavar{args} is ignored for \emph{string templates} with not more than one mandatory replacement field, and for \emph{formatter functions} -- whose arguments are completely inferred by
introspection.  However, it is \emph{required} for templates with more than one mandatory argument.  See \vref{sec:templates-templates} and
\vref{sec:functions-argument-handling} for details, \vref{fig:bookShortUse} shows an example.


\paragraph{\luavar{opt}}

If the formatter features an optional argument the \luavar{opt} field can be
used to provide a default value in the generated \LaTeX\ macro.  See
\vref{sec:templates-argument-handling} and
\vref{sec:defining:functions-optional-argument} for details.

\begin{minted}{lua}
MANUAL:add_formatter('halfwidth_image', {
	f = [[\includegraphics[<<<options>>>]{<<<image>>>}]],
	opt = [[width=.5\textwidth]],
})
\end{minted}

\noindent will create a macro whose optional argument is preset with the value
given in the \luavar{opt} field:
\mintinline{tex}{\halfwidthImage[width=.5\textwidth]{<<<image>>>}}.


\paragraph{\luavar{options}}

With an \luavar{options} table the optional argument can be validated and
populated with default values.  If it is present only the declared options may
be provided in the optional argument, and the values are validated against a
type or a list of expected values.  Also, options that are \emph{not} included
in the optional argument are populated with default values specified here. For
more information see \vref{sec:defining:templates-optional-argument} and
\vref{sec:defining:validating-optional-arguments}.  Note that while not
\emph{technically} incompatible this options should be used \emph{alternatively}
with the \luavar{opt} field.

\NOTE{Note:} Currently validating options is only supported for formatter
\emph{functions}, not templates.

\bigskip

As documented above all but the \luavar{f} fields are optional in most cases,
and you will usually only need a few of them for a reasonably encoded formatter.
\Vref{fig:bookShort} shows \emph{all} fields in action, implicitly creating the
macro \luaMacroDocInline{bookShort} with a possible use shown in
\vref{fig:bookShortUse}.

\begin{figure}
\begin{minted}{lua}
MANUAL:add_formatter('book',{
    name = 'bookShort',
    comment = 'A book definition for inline use',
    f = [[\textbf{<<<author>>>}: \emph{<<<title>>>} (<<<year>>>)]],
    color = 'magenta',
    args = {'author', 'title', 'year'},
    -- opt does not make sense here
})
\end{minted}
\caption{A “complete” formatter entry table}
\label{fig:bookShort}
\end{figure}

\begin{figure}
\luaMacroDoc[demo,args={Schoenberg,Style and Idea,1950}]{bookShort}.
\caption{Use and result of an automatically generated macro.}
\label{fig:bookShortUse}
\end{figure}


\subsubsection{Configuring Formatters}
\label{sec:usage:configuring-formatters}

Sometimes it is inconvenient to specify all relevant information in a formatter
entry table directly when declaring a formatter.  Most commonly this will
apply to formatter \emph{functions} which have been defined using Lua's function
definition idiom rather than being directly assigned in a table constructor.
For these cases it is possible to add information to existing formatters using
the command \mintinline{lua}{add_configuration((<comment>,) <configuration
table)}. The first argument is an optional string serving as a comment, just as in \mintinline{lua}{add_formatter()} above.  The table argument is a flat table whose keys are lookup keys to locate \term[Formatter Entry]{Formatter Entries} to be updated. The values are (not necessarily complete) \term[Formatter Entry Table]{Formatter Entry Tables} whose contents will be added to the updated entry, overwriting existing values if encountered.

\begin{minted}{lua}
MANUAL:add_configuration{
	reverse = {
	    name = 'revText',
	    comment = 'Reverse the given string, optionally in small caps.',
	    color = 'red',
	},
	['nested.key'] = {
		color = 'green'
	},
	old_name = 'newName'
}
\end{minted}

\noindent The first entry configures a formatter at the toplevel position
\luavar{reverse} to create the macro \cmd{revText} and adds the color and the
comment to its configuration.  Note the way the key is specified in the second
example.  This entry looks up a formatter at \luavar{nested.key}, but this isn't
actually real Lua but rather “Lua-style” syntax that is parsed internally by
\luaformatters, not by the Lua parser.  Therefore, if the \luavar{key} contains
dots it has to be given using this special Lua syntax.  The third entry
demonstrates a shorthand notation: if the value of an entry is not a table but a
string, this is considered to be the new \luavar{name} property, so essentially
this makes a formatter available as a macro with a manually specified name.
This is also used extensively for publishing hidden formatters
(\vref{sec:usage:publishing-builtin-formatters}).


\subsection{Creating Macros}
\label{sec:creating-macros}

One of the main features of this package is the automatic creation of \LaTeX\
macros from formatter declarations: each \term{Formatter Entry} that is not
explicitly marked as hidden will trigger the creation of a corresponding macro,
without requiring any code in the \LaTeX\ domain for the set-up.

\subsubsection{Macro Names}
\label{sec:usage:macro-names}

If the \term{Formatter Entry Table} includes the \luavar{name} field its value
is used literally as the macro name, otherwise the macro name is generated from
the formatter's \emph{position} in the \term{Formatters Table} according to the
following rules:

\begin{itemize*}
\item If the \term{Formatters Table} has a \luavar{prefix} field this is
prepended to the generated name.
\item The Lua-style dot-notation is concatenated to a mixedCase string,
removing all dots and making the following character uppercase.  If
\luavar{prefix} is set the first element of the list is also uppercased.
\item Any underscores in the name will also be converted to a mixedCase
rendering to produce valid \LaTeX\ names.  Note that table keys may not have an
underscore as the \emph{last} character.
\end{itemize*}

\begin{minted}{lua}
MANUAL:add_formatters('Naming examples', 'media.cds', {
	title = [[...]],
	title_short = [[...]]
})
\end{minted}

\noindent will create macros \cmd{mediaCdsTitle} and \cmd{mediaCdsTitleShort}.
If a prefix \texttt{'lib'} were defined in the \term{Formatters Table} they would
instead be \cmd{libMediaCdsTitle} and \cmd{libMediaCdsTitleShort}.

\begin{minted}{lua}
MANUAL:add_formatter('complex.nested.namespace.cmd',{
	f = [[Something]],
	name = 'shortName'
})
\end{minted}

\noindent However, in this case, not \cmd{complexNestedNamespaceCmd} is created but \cmd{shortName}.


\subsubsection{Hidden formatters}
\label{sec:usage:hidden-formatters}

If the given name of a formatter or any of the path segments within the key
of a formatter (that hasn't explicitly been named) starts with an underscore the
formatter is considered marked as hidden, and no \LaTeX\ macro is created for
it.  The formatter is still available from within Lua but does not pollute the
\LaTeX\ namespace.  All of the following formatters would be hidden:

\begin{minted}{lua}
MANUAL:add_formatter('_hidden', [[A hidden formatter]])
MANUAL:add_formatter('some.key', { name = '_h', f = [[Also hidden]]})
MANUAL:add_formatters('All hidden', 'hidden._subtree', {
	a = [[A]],
	b = [[B]],
	c = [[C]]
})
\end{minted}

\noindent Note that in the last example the whole \emph{subtree} is hidden,
which would also be true for any further nesting below
\luavar{hidden.\_subtree}.

It is possible to hide formatters both through their \emph{key} and through a
dedicated \emph{name}.  While the difference has no practical consequences it
can be exploited to send different “messages” to potential users.  The
\luavar{name} of a formatter is determined from the \luavar{key}, so when the
key has a “hidden” name and no explicit name is given no macro is created. But
when the key is not hidden and a hidden name is explicitly given, there isn't a
macro either. By storing a formatter in a “clean” key and hiding it through the
\luavar{name} field one can signal that the formatter is free to be reused,
while hiding through the \emph{key} may suggest that a formatter is actually
intended for private use only.

\subsubsection{Argument handling}
\label{sec:usage-argument-handling}

Great care has been taken to make the creation and handling of \LaTeX\ macro
arguments as simple and robust as possible.  If the formatter is a
\emph{function} then the named arguments are mapped to the mandatory macro
arguments \emph{by their order}, except if one argument is named
\luavar{options}, in which case this will be mapped to the macro's optional
argument, regardless of its position in the argument list. This process is
completely automatic.

\begin{minted}{lua}
function MANUAL:formatters:foo() return 'Hey' end
function MANUAL:formatters:bar(one, two, three) return one .. two .. three end
function MANUAL.formatters:baz(text, options) return one end
\end{minted}

\noindent will result in the macros

\begin{itemize*}
\item \mintinline{tex}{\foo}
\item \mintinline{tex}{\bar{one}{two}{three}}
\item \mintinline{tex}{\baz[]{text}}
\end{itemize*}

\noindent The situation is somewhat different with \emph{templates} where macro
arguments can't \emph{always} be inferred automatically.  For the field
replacement in templates the numbered arguments are mapped to \emph{field names}
that unlike function arguments have no inherent order.  This means that if a
template has more than one \emph{mandatory} field the argument order has to be
manually specified using the \luavar{args} field of the \term{Formatter Entry
Table}.  However, a field named \luavar{<<<options>>>} can automatically be
processed because it will always be the \emph{first} macro argument, and if
there are zero or one additional named arguments the macro can be generated
automatically.

\begin{minted}{lua}
MANUAL:add_formatters{
	foo = [[No mandatory argument]],
	bar = [[\textit{<<<arg>>>}]],
	baz = [[\fbox[<<<options>>>]{<<<content>>>}]],
}
\end{minted}

\noindent will without manual configuration create the macros

\begin{itemize*}
\item \mintinline{tex}{\foo}
\item \mintinline{tex}{\bar{arg}}
\item \mintinline{tex}{\baz[]{content}}
\end{itemize*}

\noindent while the following formatter with \emph{two} named replacement fields requires the \luavar{args} field to specify the argument order:

\begin{minted}{lua}
MANUAL:add_formatters{
	floatImage = {
		f = [[
\begin{figure}
\includegraphics[<<<options>>>]{<<<image>>>}
\caption{<<<caption>>>}
\label{fig:<<<image>>>}
\end{figure}]],
		args = { 'image', 'caption' }
	}
}
\end{minted}

\noindent and produce the macro \mintinline{tex}{\floatImage[]{image}{caption}}.

The optional argument can automatically be validated in formatter
\emph{functions}, for more information see
\vref{sec:defining:functions-optional-argument}.

\subsubsection{Publishing Built-in (and other hidden) Formatters}
\label{sec:usage:publishing-builtin-formatters}

In addition to completing the information for registered formatters
(\vref{sec:usage:configuring-formatters}) \mintinline{lua}{add_configuration()} can
also be used to “publish hidden formatters to create \LaTeX\ macros
nevertheless.  While it doesn't make any sense to declare formatters as hidden
only to publish them afterwards \emph{within one package} there are valid use
cases where one package defines hidden formatters to be on the one hand useful
building blocks accessible to Lua functions and on the other hand to be
selectively publishable by \emph{other} packages.  The most prominent example of
this is a collection of \term{Built-in Formatters} defined by
\luaformatters\ itself, which is documented in
\vref{sec:defining:builtin-formatters}.

Publishing hidden formatters essentially involves renaming them to non-hidden names, so the typical way of doing it is to simply assign a new name to a function previously hidden through an underscore:

\begin{minted}{lua}
MANUAL:add_configuration{
	list_format = 'names'
}
\end{minted}

\noindent which will publish the formatter found at position \luavar{list\_format} as the macro \cmd{names}.  (Note that built-in formatters all reside at toplevel keys (without underscores) but are hidden through their \luavar{name} properties.)

Since built-in formatters are always \emph{functions} it is not necessary to
provide \luavar{args}, but comments and colors may be useful additions.
However, this is not necessarily true for hidden formatters from \emph{other}
sources like third-party packages, so there may be the need for more complete
configuration in such cases.


\section{Defining Formatters}
\label{sec:defining-formatters}

The core of working with \luaformatters\ is the definition of
\term[Formatter]{Formatters}.  As has already been discussed a \term{Formatter}
is either a string template or a Lua function that is wrapped in a
\term{Formatter Entry Table} and stored in the \luavar{formatters} subtable of a
\term{Formatters Table}, from where eventually a \LaTeX\ macro will be created.
From the perspective of client code \emph{using} the formatter -- be it a
\LaTeX\ macro or a Lua function -- there's no difference between templates and
macros: both are called through \mintinline{lua}{lua_formatters:format('key',
<args>)}.  This transparency is an important feature of \luaformatters
as it makes it easy to change the implementation of a formatter from template to
function and vice versa.

This chapter discusses the various types of formatters and gives a basic introduction into writing \term{Formatter} \emph{functions}.


\subsection{String Templates}
\label{sec:usage:string-templates}

\emph{Formatters} in \luaformatters\ are text strings with zero to nine
\emph{different} replacement fields (corresponding to the number of possible
macro arguments in \LaTeX), while the \emph{same} field can be used multiple
times within a template.  Upon usage the fields are replaced with content from
either a (Lua) function call or a \LaTeX\ macro argument.  Conceptually one can
differentiate between \emph{shorthands}, \emph{styles} and \emph{templates},
based on the number of arguments, although from a technical perspective they are
handled identically.


\subsubsection{Argument Handling}
\label{sec:templates-argument-handling}

\luaformatters\ tries to infer arguments from formatters as much as
possible to simplify their declarations.  However, with \emph{templates} it is
not always possible to fully automate the process, which is detailed in the
following subsections.

\term[Replacement Field]{Replacement fields} are represented through a name
surrounded by three pairs of angled brackets, like e.g. \luavar{<<<title>>>}. As
said, up to nine different fields can be used within a template, and each of
them will be mapped to one argument of a \LaTeX\ macro.  If a field is used
multiple times the corresponding value is inserted multiple times in the result
too. Note that the mapping of arguments to replacement fields is done \emph{by
name} and not \emph{by order}.  This is crucial because the natural order in
which one would want arguments to be encoded doesn't necessarily have to match
the order in which they appear in the template (one can relate that to
traditional \LaTeX\ coding where \texttt{\#1 \#2 \#3} don't necessarily appear
in that order in macros). And -- more importantly -- modifying a template can
involve reordering the occurences of field names. Consider the definition of the
\cmd{bookShort} macro above on page \pageref{fig:bookShort}, requiring the three
arguments \luavar{author}, \luavar{title} and \luavar{year}.  Changing the
rendering of that macro to \texttt{<author> (<year>): <title>} should simply
require to change the template while the order of the macro arguments must be
kept consistent to avoid breaking existing documents.  Therefore templates with
more than one (mandatory) argument must be provided with an array in the
\luavar{args} field of the \term{Formatter Entry Table} that specifies the order
in which mandatory arguments are mapped to field names.  See the following
sections for examples.


\subsubsection{Optional Argument}
\label{sec:defining:templates-optional-argument}

Technically the names don't matter since they don't have to be used in the
end-user document, but they are used in the self-documentation, so it's always a
good idea to use speaking names, probably using CamelCase to make up for the
missing hyphens.  However, there's one exception to the rule: A field
\luavar{<<<options>>>} will always be mapped to an optional argument.  Since
there is no processing involved (other than with formatter functions, see below)
such a replacement field can only be used in a place where an optional argument
is expected in the resulting macro code.  See the \cmd{image} definition in
\vref{sec:templates-templates} for a working example.  With the \luavar{opt}
field of the \term{Formatter Entry Table} a default value for the optional
argument can be specified.


\subsubsection{Shorthands}
\label{sec:shorthands}

\emph{shorthands} are simple strings that are called through a macro, which can
be used to save typing and to ensure orthotypographic consistency.  This can be
useful for consistent appearance of, say, abbreviations like
\luaMacroDocInline[demo,nocomment]{BaB}, or an easy handle to specific brands or
other names like \luaMacroDocInline[demo,nocomment]{cary}.%
\footnote{\url{https://www.themorgan.org/music}} %

\begin{minted}{lua}
MANUAL:add_formatters{
    formatters = {
        BaB = [[B\,\&\,B]],
        cary = [[Mary Flagler Cary Music Collection \emph{(Pierpont Morgan Library)}]],
    }
}
\end{minted}


\subsubsection{Styles}
\label{sec:defining:styles}

\emph{styles} are templates with exactly one (mandatory) replacement field,
which will be converted to \LaTeX\ macros with one mandatory argument.  In their
simplest form they work like character styles, applying formatting to some text
(\luaMacroDocInline[demo,nocomment]{textbfit}), but of course they can be used
to add arbitrary visible elements to the content.  This too can be used to
ensure orthotypgraphic consistency, as exemplified in the command \cmd{DV}
(“Deutsch-Verzeichnis”), which on its first level adds a small caps \textsc{d}
and a thin space before the number
(\luaMacroDocInline[demo,nocomment,args=911]{DV}).%
\footnote{This will be expanded in \vref{sec:advanced:modular:local-formatters}
when discussing the reuse of formatter \emph{functions}.}

\begin{minted}{lua}
MANUAL:add_formatter('DV', {
    f = [[\textsc{d}\,<<<dnumber>>>]],
    comment = 'Deutsch-Verzeichnis (Cataloque of Schubert's works)',
})
\end{minted}

\noindent But since styles are defined as “macros with one mandatory argument”
their use isn't limited to actual “styles”, and additionally they can make use
of an optional argument.  The following example template shows how that can be
achieved:

\begin{minted}{lua}
MANUAL:add_formatter('image', {
    f = [[\includegraphics[<<<options>>>]{\mediadir/<<<image>>>}]],
    color = 'nocolor',
    opt = 'width=2cm',
})
\end{minted}

\noindent The resulting macro looks like this: \luaMacroDocInline{image}, with
an optional and one mandatory argument.  Since the position of the optional
argument is fixed at \texttt{\#1} the arguments can in this case still be
retrieved automatically without the need for manual configuration. The optional
argument to \cmd{includegraphics} is preset to \luavar{width=2cm}, while the
image name is appended to a media directory path (which is also defined as a
shorthand in the templates table).  \luavar{'nocolor'} is necessary to prevent
the graphics inclusion to be wrapped in a coloring command. So the invocation
\mintinline{tex}{\image{Tux}} would result in an image of width 2\,cm, while the
following forces the height to 1\,\emph{em}:
\luaMacroDocInline[demo,args={height=1em,Tux}]{image}%
\footnote{Image \textcopyright\ \url{lewing@isc.tamu.edu} Larry Ewing and The
GIMP, \url{https://commons.wikimedia.org/w/index.php?curid=80930}}


\subsubsection{Templates}
\label{sec:templates-templates}

\term[Template]{Templates} in \luaformatters's terminology are template strings
with more than one mandatory replacement field.  In order to create \LaTeX\
macros for such templates it is necessary to provide an array with argument
names in the formatter entry table's \luavar{args} field (a failure to do so
will abort the compilation).  This array holds the names of all \emph{mandatory}
arguments in the order they should be used in the macro.  As said this is
necessary to construct the by-name mapping of macro arguments to replacement
fields, therefore the names in the array must match the field names present in
the template. \Vref{fig:template} shows a formatter definition with multiple
mandatory arguments, an optional argument, and an argument occuring twice.
Thanks to the \luavar{args} array this is converted to the macro
\luaMacroDocInline{floatImage}, this time with the options \emph{not} set to a
default value.  Note how the \luavar{<<<image>>>} field is used twice in this
template.  Using the label \luavar{fig:Tux} it is possible to reference the
floating environment (\vref{fig:Tux}).


\begin{figure}
\begin{minted}{lua}
MANUAL:add_formatter('floatImage', {
    f = [[
\begin{figure}
\centering
\includegraphics[<<<options>>>]{\mediadir/<<<image>>>}
\caption{<<<caption>>>}
\label{fig:<<<image>>>}
\end{figure}
]],
    args = {'image', 'caption'},
    color = 'nocolor',
})
\end{minted}
\caption{Definition of a template formatter with two mandatory and one optional argument.}
\label{fig:template}
\end{figure}

\luaMacroDoc[demo,args={width=3cm,Tux,A scaled Tux in a floating environment}]{floatImage}



\subsection{Formatter Functions}
\label{sec:usage:formatter-functions}

\emph{Formatter functions} are Lua functions to create parametrical macros of
arbitrary complexity.  They have access to all the templates, other custom
formatters (to make programming more modular) and a number of built-in
formatters assisting in often-used parsing and formatting tasks.  Like with
templates \LaTeX\ macros are automatically created if the formatter is not
explicitly “hidden” through a leading underscore in the formatter name.

Formatter functions are intended for cases where the argument(s) have to be
\emph{processed}, and the limits are really only the imagination and the
capabilities of Lua.  For example the text could be formatted differently
depending on the context (e.g. track progress and color elements alternatingly),
use the argument as a key to something like external database access or an
URL (e.g. insert an image from the web),%
\footnote{See the \package{getmap} package as an example which downloads and
displays map excerpts from OpenStreetMap (\url{https://ctan.org/pkg/getmap})} %
or kick off some algorithmic processing resulting in a diagram presentation etc.

\medskip

Formatter functions are Lua functions with the following characteristics:

\begin{itemize*}
\item They receive a leading \luavar{self} argument.
\item They may accept zero to nine named arguments, which are mapped to \LaTeX\
macro arguments.
\item The arguments receive \emph{string} values from the \LaTeX\ macro.  It is up to the function to process them as other data types.
\item One of these arguments (at an arbitrary position) can be named \luavar{options} and will then be mapped to the macro's optional argument.
\item They have to return a string that will be used as the resulting \LaTeX\
content or within another, calling, Lua function.
\end{itemize*}

\noindent Note that the formatter \emph{is given} some data and expected to
\emph{return} that processed string, but \emph{writing back to \LaTeX} is
\emph{not} its responsibility.  This is transparently taken care of by the
\luaformatters\ machinery, which at that stage also controls the optional
coloring.

During the set-up process a formatter function is to some extent modified by
\luaformatters\ and wrapped in an instance of the \luavar{Formatter}
class (although that is very similar to a \term{Formatter Entry Table}). At this
point this is just an aside, and \vref{sec:advanced-programming} will go into
much more detail.  For simple, self-contained formatter functions  -- and this
is what is discussed exclusively in this chapter -- there is nothing special to
take care of, but it's important to be aware of the fact that there is some
magic going on behind the scenes and the parent-child or sibling relations are
not necessarily as they seem at definition time.


\subsubsection{Function Definition}
\label{sec:defining-function-definition}

It has already been mentioned in \vref{sec:usage:declaring-formatters} that formatter functions can be defined in several ways, but this will be repeated with a little more detail now.


\paragraph{Standalone Function Definition}

For functions it is most common to use the ordinary Lua idiom of standalone function definition, defining the function below \luavar{MANUAL.formatters}

\begin{minted}{lua}
function MANUAL.formatters:foo(text)
    return '|' .. text .. '|'
end
\end{minted}

\noindent which automatically produces a \LaTeX\ macro
\luaMacroDocInline[demo,args=Foo]{foo} that wraps its argument \luavar{text}
with two pipe symbols.  From the perspective of readability and maintainability
of the file this is probably the recommendable approach in most solutions.
However, there are two caveats to this syntax that have to be considered.

In order to define a function the parent table must already exist, which means
that in order to define a function

\begin{minted}{lua}
function MANUAL.formatters.my.personal.commands:bar(text)
    return text .. ' | ' .. text:reverse()
end
\end{minted}

\noindent the “namespace” \luavar{my.personal.commands} has to be defined first,
for example with

\begin{minted}{lua}
MANUAL.formatters.my = {
	personal = {
		commands = {}
	}
}
\end{minted}

\noindent or -- of course preferably -- the \luaformatters\ function

\begin{minted}{lua}
MANUAL:provide_namespace('my.personal.commands')
\end{minted}

\noindent This limitation can't be avoided by the \luavar{strict=false} option
of \luaformatters.  A typical workaround (or rather: situation that
takes the problem away by itself) is to first specify the \emph{templates} using
the tools provided by \luaformatters\ and only then -- having created the
namespace already -- define the \emph{functions}, which typically reside in the
same namespace.

\medskip

It has also to be considered that the standalone function definition does \emph{not} allow the declaration of a \term{Formatter Entry Table}.  So if any element out of coloring, (self-documentation) comment, or alternative macro name is required this has to be added separately in a configuration clause (\vref{sec:usage:configuring-formatters}).  It is up to the package author to decide which form of entry is more convenient and maintainable; of course it should be applied consistently within a package.

\paragraph{\luaformatters\ Interface}

\luaformatters\ provides two functions that can equally be used to define
formatter functions: \mintinline{lua}{FormattersTable:add_formatter()} and
\mintinline{lua}{FormattersTable:add_formatters()}.  However, this has some
specifics to be taken care of:

\begin{minted}{lua}
MANUAL:add_formatter('foo', function(self, text) return '|' .. text .. '|' end)
-- or
MANUAL:add_formatters{
	foo = function(self, text) return '|' .. text .. '|' end,
	bar = ...
}
\end{minted}

\noindent In the first case the function is an argument to the
\luavar{add\_formatter} function, while in the second case it is assigned as a
value in the \emph{table} passed as an argument.  In both cases the colon
notation is not available, and the function must specify the \luavar{self}
argument in the first position explicitly.  Also to be noted is that in both
cases the function \emph{name} is not part of the definition (as is in the
\luavar{function <name>} syntax) but part of the context where the definition is
placed in.  This is particularly relevant in the second version where the
function definition happens as a value assignment within a table constructor and
should therefore be followed by a comma to separate it from any following table
fields -- failing to provide that is an easy-to-occur and hard-to-spot omission.

Finally it should be mentioned that -- as these \luaformatters\ functions assign
a function to a variable it is also possible to assign a function that has
previously been defined, for example as a local function, which would also give
access to create closures (as demonstrated in the example
\vref{sec:examples:closures}).

\begin{minted}{lua}
local function foo_local(self, text)
    return '|' .. text .. '|'
end
MANUAL:add_formatter('foo', foo_local)
\end{minted}

\noindent Presumably there will rarely be a case for this to be necessary --
except if one would need to assign a \emph{variable} function that is
conditionally returned by a local “chooser” function.  Note that here the
\luavar{self} argument has to be declared explicitly too.

\paragraph{Alternative function definition}

Finally it should be mentioned briefly that formatter functions can -- along with templates -- also be defined directly inside the table constructor of the table that will be passed to \luavar{lua\_formatters:new()}:


\begin{minted}{lua}
MANUAL = {
    ...
    formatters = {
        foo = function(self, text) return '|' .. text .. '|' end,
        baz = ...
    },
	...
}
\end{minted}

\noindent is functionally the same as the previous definitions.  The major
downside to defining functions in the table constructor is that it tends to
become less readable than the “standalone” definition, especially when functions
and/or the namespace get more complex.  On the other hand the relations within
the namespace tree become much more obvious this way
(\vref{fig:inline-function-definition} shows this in a more deeply nested
hierarchy). Again, this is functionally equivalent to the previous definition
style, and I think it's obvious how this is rather “fragile” in terms of
readability and especially maintainability but at the same time more explicit.

\begin{figure}
\begin{minted}{lua}
MANUAL = {
    ...
    formatters = {
		bar = [[\textbf{A dummy template}]],
        tools = {
            text = {
                baz = {
                    f = function(self, text)
                        return text .. ' | ' .. text:reverse()
                    end,
                    color = 'red',
                },
                baz = ...
            },
            ...
        },
        ...
    },
    ...
}
\end{minted}
\caption{Integration of a function definition in the table constructor}
\label{fig:inline-function-definition}
\end{figure}

In the end this is a matter of the specific needs of a project and/or personal
preference.


\subsubsection{The \luavar{self} Argument}
\label{sec:defining:the-self-argument}

It has been said that formatter functions must accept a \luavar{self} argument,
even if they don't make use of it.  When the formatter is called from a \LaTeX\
macro this variable will refer to the \luavar{Formatter} object the function is
wrapped in (\vref{sec:advanced:the-formatter-table}), and when called from a Lua
function through \mintinline{lua}{self:format()} this is also the case. However,
due to some metatable handling by \luaformatters\ there are further methods and
variables that can be accessed directly through \luavar{self.} or
\luavar{self:}.  For basic formatter programming as discussed in the current
chapter the main functionality of interest are the built-in support functions
documented in \vref{sec:defining:support-functions}, further options are
described in \vref{sec:advanced:modular-design-principles}.


\subsubsection{Argument Handling}
\label{sec:functions-argument-handling}

Named arguments specified in a formatter function's signature are automatically
mapped to \LaTeX\ macro arguments, it is not necessary to separately declare
them to \luaformatters\ or take care of their order: a function with the
signature \mintinline{lua}{function foo(text, key, fancy)} will generate the
macro \mintinline{tex}{\foo{text}{key}{fancy}}.  Any \luavar{args} field that
might be provided in a \term{Formatter Entry Table} will simply be ignored.

All arguments provided by a \LaTeX\ macro will necessarily be \emph{strings}, so
in order to use them as anything different the function is responsible to
convert them to or parse them as suitable data types.  Note that it is possible
to specify a table-like argument by writing them as a comma-separated list of
\texttt{key=value} pairs or keys and processing it with
\mintinline{lua}{self:check_options(<arg>)} as described in the following
section.

Note that it is \emph{not} possible for formatters (at least if they are intended to be published as \LaTeX\ macros) to have a variadic \luavar{...} argument.


\subsubsection{Optional argument}
\label{sec:defining:functions-optional-argument}

If one of the arguments specified by a formatter function is named \luavar{options} then it will be automatically mapped to a \LaTeX\ macro's optional argument.

\begin{minted}{lua}
function MANUAL.formatters:reverse(text, options) ... end
\end{minted}

\noindent will result in a macro \mintinline{tex}{\reverse[options]{text}}. The
\luavar{options} argument can be placed at an arbitrary \emph{position}, but it
seems most natural to put the optional argument at the end of the argument list.

Optional arguments in formatter \emph{functions} are significantly more powerful
than in string \emph{templates} because they can not only be used as simple
strings passed along to the optional argument of a \LaTeX\ macro but are treated
as real \texttt{key=value} options.  While originally being a string argument in \LaTeX\ the \luavar{options} variable available within the formatter function has transparently been converted to a (potentially empty) table.
Given the \LaTeX\ macro invocation

\begin{minted}{tex}
\reverse[upper,interval=3,parsed=false,width=.5\textwidth]{Text}
\end{minted}

The \luavar{options} variable as seen inside the function is

\begin{minted}{lua}
options = {
	upper = true,
	interval = '3',
	parsed = false,
	width = '.5\textwidth'
}
\end{minted}

\noindent Note that giving an option without a value will set its value to
\luavar{true}, and that the boolean values are converted to real booleans while
other values are still strings that have to be handled appropriately by the
function itself. Which usually \emph{is} what is desired because in the end
these variables will typically be written back to \LaTeX\ anyway, e.g. as
arguments to other macros.%
\footnote{\NOTE{TODO:} Look for functionality to convert other datatypes, if
that should be what is necessary, e.g. for calculations. Probably that's
implemented in lyluatex-lib already.}

In some cases it is necessary to treat the optional argument not as a
\texttt{key=value} option list but as a single string, e.g. if the argument is
just optionally providing a single value.  For these cases the processed
\luavar{options} table contains original string in the field \luavar{options[1]}
which can be used instead of the regular lookup keys.  If no optional argument
has been given this field will contain an empty string.  See
\vref{sec:examples:closures} for an example.

\paragraph{Manual Option Processing}

While the original preprocessing of the \luavar{options} variable is done
transparently by the \luavar{Formatter} object before its formatter function is
called manual post-processing is necessary when options are not atomic but
comma-separated option lists themselves.  For this purpose two of the built-in
support functions (\vref{sec:defining:support-functions}) can be used:
\luavar{self:split\_list()} and \luavar{self:check\_options()}.

Enclosed in curly brackets, option values may themselves be comma-separated
lists of \texttt{key=value} options. These will initially be parsed to strings
in the \luavar{options} table, and in order to access them as sub-options this
field can be processed by one of the two functions separately.

\begin{minted}{tex}
\foo[edition=2,instruments={violin,piano}]
\end{minted}

\noindent will be converted to

\begin{minted}{lua}
options = {
	edition = '2',
	instruments = 'violin,piano'
}
\end{minted}

\noindent If it can be guaranteed that the options consists of a flat list of
keys like in this example it can be converted to an array:

\begin{minted}{lua}
inst_options = self:split_list(options.instruments, ',')

=> inst_options = { 'violin', 'piano' }
\end{minted}

\noindent However, option values may not always be arrays but can also be
\texttt{key=value} tables themselves:

\begin{minted}{tex}
\book[author=Franz Kafka,
publication={edition=2,year=1935,ed=Max Brod}]{Der Process}
\end{minted}

\noindent will initially result in the table

\begin{minted}{lua}
options = {
	author = 'Franz Kafka',
	publication = 'edition=2,year=1935,ed=Max Brod'
}
\end{minted}

\noindent which can be processed to a separate table with the following command:

\begin{minted}{lua}
pub_options = self:check_options(options.publication, true)

=> pub_options = {
	edition = '2',
	year = '1935',
	ed = 'Max Brod'
}
\end{minted}

\noindent Note the second argument \luavar{true} which is typically necessary to
skip the validation described in the next section.


\subsubsection{Validating Optional Arguments}
\label{sec:defining:validating-optional-arguments}

The \package{luaoptions} package this option handling is built upon also
provides functionality to \emph{validate} options and optional arguments, both
with regard to “known options” and to expected option types or values.
\luaformatters\ can make this validation available to formatter
functions, simply by adding a \term{Option Declaration} to the formatter's
\term{Formatter Entry Table} (since functions will often be defined “standalone“ this will typically take place in a separate configuration step.)

\begin{minted}{lua}
MANUAL:add_configuration{
	'reverse' = {
		options = {
			['upper'] = { 'false', 'true', '' },
		}
	}
}
\end{minted}

\noindent This “declares” one single boolean option for the \luavar{reverse}
formatter with default value \luavar{false}.  This has three consequences: the
optional argument can have \emph{no other} option than \luavar{upper}, its value
is restricted to one out of \luavar{false}, \luavar{true}, and empty (only the
key, without an \luavar{=}). Finally, even if missing in the macro invocation,
the resulting \luavar{options} table will always have the \luavar{upper} field,
preset to the default, \texttt{false}.

The options and syntax of option declaration is covered in the manual for the
\package{luaoptions} package.%
\footnote{\NOTE{NOTE:} Currently this is not the case, the manual for
\package{luaoptions} will only be completed by the \texttt{v1.0} release of
\luaformatters.}

\subsubsection{Built-in Formatters}
\label{sec:defining:builtin-formatters}

\luaformatters\ implements a substantial number of \term[Built-in
Formatter]{Built-in Formatters} that can be used from everywhere in the Lua
code, especially from within custom formatting functions, providing an easy way
to modularize the development of formatters.  A \term{Built-in Formatter} can be
called from a formatter function using \mintinline{lua}{self:format('<key>',
<args>)}, will accept various numbers of arguments (as documented below) and
always return a processed string that can either be forwarded as the calling
formatter's return value or used in further processing.

\term[Built-in Formatter]{Built-in Formatters} also provide convenient end-user
macros for general formatting tasks.  Since they have pretty generic names it
didn't seem like a good idea to create macros for them by default, therefore
they are defined to be initially hidden.  But as described in
\vref{sec:usage:publishing-builtin-formatters} they can be selectively exposed
to \LaTeX\ with their original or arbitrary names.  Additional useful support
functions defined by \luaformatters\ but not intended to be published as \LaTeX\
macros are documented in \vref{sec:defining:support-functions}.

The following example works with the built-in formatter \luavar{range}'s return value:

\begin{minted}{lua}
function MANUAL.formatters:check_range(text)
    local processed = self:format('range', text)
    if processed ~= text then
        text = processed .. string.format([[ (input was: \texttt{\{%s\}})]], text)
    end
    return text
end
\end{minted}

\noindent As documented below \luavar{range} will either format a range or
return the unmodified input as a single value.  \cmd{checkRange} test this and
either returns the original number as-is or appends a comment if \luavar{range}
has modified the input: \mintinline{tex}{\checkRange{5}} will produce
\checkRange{5} while \mintinline{tex}{\checkRange{6-8}} yields \checkRange{6-8}.


\medskip

\noindent
The following built-in formatters are available:

\paragraph{\luavar{add\_subscript} / \luavar{add\_superscript} (base, sub/super, parenthesis)}

Add a sub/superscript.

\begin{itemize*}
\item \luavar{base}: The base string to be extended
\item \luavar{sub/super}: The text to be added.\\If this is empty the original
\luavar{base} is returned.
\item \luavar{parenthesis}: If a true value add parentheses around the added text%
\footnote{See \url{https://github.com/uliska/luaformatters/issues/16}}
\end{itemize*}


\paragraph{\luavar{add\_element} (base, element, separator)}

Add an element to a list.

\begin{itemize*}
\item \luavar{base}: The current texte of the list. If this is empty, return
the added element alone.
\item \luavar{element}: The element to be added. If this is empty, return the base
alone.  Otherwise join \luavar{base} and \luavar{element} with \luavar{separator}.
\item \luavar{separator}: Separator between list elements.  If this is missing
use the package option \luavar{element-separator}.
\end{itemize*}


\paragraph{\luavar{bold} (text)}

Return text as boldface.

\paragraph{\luavar{capitalize} (text)}

Make the first letter in the given word/string uppercase.


\paragraph{\luavar{case} (case, text)}

Process the case of the given text.  \luavar{case} is one out of the following
implemented strategies:

\begin{itemize*}
\item \luavar{normal}: Return unmodified
\item \luavar{smallcaps}: Apply small caps
\item \luavar{allsmallcaps}: Convert to lowercase and apply small caps
\item \luavar{upper}: Convert to uppercase
\item \luavar{lower}: Convert to lowercase
\end{itemize*}

\noindent More case strategies may be added, see
\url{https://github.com/uliska/luaformatters/issues/2}.

\paragraph{\luavar{emph} (text)}

Emphasize the given text (using \cmd{emph}).

\paragraph{\luavar{italic} (text)}

Make the given text use italics.

\paragraph{\luavar{list\_format} (text, options)}

Format the given text as a \package{biblatex}-like list.  By default the input
is split into a list at the key \texttt{' and '} and returned using the
separators specified by the package options \luavar{list-sep} and
\luavar{list-last-sep}.  These can be overridden by the options
\luavar{input\_separator}, \luavar{separator} and \luavar{last\_separator}.

With the option \luavar{formatter} the key to a formatter can be given that each
list element will be passed through.  The formatter must accept exactly one
mandatory argument, but apart from that both custom and built-in formatters may
be used at will.

\begin{minted}{tex}
\names[formatter=bold]{Haydn and Mozart and Beethoven}
\end{minted}

\noindent will return a list where each of the elements has been formatted with
the built-in \luavar{bold} formatter: \names[formatter=bold]{Haydn and Mozart
and Beethoven}.



\paragraph{\luavar{list\_join} (elements, options)}

Join the list to a string.

By default use the package options \luavar{list-sep} and \luavar{list-last-sep}
as the separators. These can be overridden  by the options \luavar{separator}
and \luavar{last\_separator}.

It is planned to add \package{biblatex}-style list compression too (see
\url{https://github.com/uliska/luaformatters/issues/4}).

\paragraph{\luavar{number} (text, options)}

Format numbers.

If the given text is a number or contains backslashes it is returned unmodified
(having a backslash implies that the whole item is already a formatted
entity). Otherwise it is piped through the \luavar{case} formatter, using either
the package option \luavar{number-case} or the given option of the same name.


\paragraph{\luavar{range} (text, options)}

Formats a (number) range.

Parse and then format a range, with some specific features and configuration
options.  A range is always split at a single hyphen (so \texttt{3--5} would be
split into \texttt{3} and \texttt{-5}).  Then a formatted is applied to each
element, by default this is \luavar{number} formatter (with the options
documented there).  However, if the second element of the range is \texttt{f} or
\texttt{ff} the range separator is removed and the value of the package option
\luavar{range-follow} or \luavar{range-ffollow} is used instead:
\mintinline{tex}{\range{5-f}} will thus produce \range{5-f} and
\mintinline{tex}{\range[number-case=upper]{xiv-xvii}} comes out as
\range[number-case=upper]{xiv-xvii}.


\paragraph{\luavar{range\_list} (text, options)}

Format a list of ranges (e.g. for paginations).

Formats a list, using \luavar{range} as the formatter.  Any options are passed
on the the \luavar{list\_format} formatter.  This is a pretty powerful tool for
formatting complex page ranges: text can be inserted like a \package{biblatex}
list field:
\mintinline{tex}{\pages{1 and 5-6 and xiv-ff and
123}}, which will turn out as
\textcolor{blue}{1, \range{5-f}, \range{xiv-ff} and 123}.%
%\footnote{TODO: Fix this once issue \#5 has been fixed. (\pages{1 and 5-6 and xiv-ff and 123}).}


\subsubsection{Support Functions}
\label{sec:defining:support-functions}

The \luavar{Formatters} class provides a number of useful helper functions that
can be used in formatters to perform common tasks and make programming macros a
bit easier.  In a way they are similar to the \term[Built-in Formatter]{Built-in
Formatters} (\vref{sec:defining:builtin-formatters}), but they are not accessed using the
\luavar{format()} method, and they do not always return simple strings.

From within a \term{Formatter} these functions can be accessed using the
\luavar{self:} notation.


\paragraph{\luavar{check\_options} (options)}

Process an optional argument, return a table.

\noindent Takes the content of an optional argument, which can be either a
(potentially empty) string (when passed in from a \LaTeX\ macro or a Lua
function) or a table or \luavar{nil} (if passed in from a Lua function).  If the
input is empty (nil or an empty string) an empty Lua table is returned.  If the
input already is a table it is returned unmodified.  If it is a non-empty string
it is parsed using \package{lyluatextools} functionality.  If an option's value
is an empty string or the string \luavar{'true'} the entry is set to the boolean
value \luavar{true}.

Note that if a value is a comma-separated list (protected by curly brackets)
this value is returned as a single string, leaving the responsibility of further
processing to the caller.


\paragraph{\luavar{format} (key, ...)}

Apply a registered \term{Formatter}

\noindent Locates a registered \term{Formatter} by its key and calls it.
\luavar{format()} passes all additional arguments to the formatter, and it is
the caller's responsibility to provide matching number and types of arguments.

If the formatter is a \emph{function} then the arguments must simply match its
signature, but with templates there are various options.  Always possible is to
provide a single \term{Replacement Table} mapping field names to values.  If the
templates doesn't provide replacement fields it is also possible to call the
formatter without arguments, and if it contains \emph{one} replacement field it
is possible to simply provide a single argument which will be used to populate
that field.  For more than one replacement field a mapping between arguments and
field names must be established, but in addition to providing this through a
single table argument it is also possible to provide an \luavar{args} array as
first argument, followed by values that will be mapped according to the keys
given in the array.  The following two assignments are equivalent:

\begin{minted}{lua}
local result = self:format('foo', { 'argone', 'argtwo' }, valone, valtwo)
local result = self:format('foo', {
	argone = valone,
	argtwo = valtwo
})
\end{minted}


\paragraph{\luavar{\_format} (key, ...)}

Apply a registered local \term{Formatter}

Local formatters are only available to the \term{Client} where they have been
registered.  They behave \emph{nearly} identical to regular formatters except
for two differences, which are the result from the fact that local formatters
\emph{never} produce \LaTeX\ macros:  local formatters are not limited to nine
named arguments, and -- more importantly -- they don't have to return one single
string. Instead they can return arbitrary data types or multiple return values.
Apart form that handling is identical to the \luavar{format()} function
described just above.


\paragraph{\luavar{split\_list} (text, pattern)}

Split a text to a list at a given pattern.

\noindent Takes a string that is meant to represent a list and return that list as a Lua array.  \luavar{pattern} may include spaces that will then not be part of the resulting elements.

\begin{minted}{lua}
self:split_list('one and two and three', ' and ')
=> { 'one', 'two', 'three' }
\end{minted}


\paragraph{\luavar{split\_range} (text, separator)}

Split a range into its components.

\noindent Takes a string that is meant to represent a range and return
\luavar{from} and \luavar{to} fields.  If the text is \emph{not} a range then
\luavar{to} will be \luavar{nil}.

Note that this will consider everything after the \emph{first} range separator
as part of the \luavar{to} part, so \luavar{3--4} would be split into \luavar{3}
and \luavar{-4}. For strings that might include more than two segments
\luavar{split\_list()} would be available.

Note that the separator is not configurable yet but still hardcoded to be a
single hyphen (\url{https://github.com/uliska/luaformatters/issues/18}).

\begin{minted}{lua}
self:split_range('6-8')
=> '6'  '8'

self:split_range('55')
=> '55'  nil

self:split_range('9-12-16')
=> '9'  '12-16'
\end{minted}


\paragraph{\luavar{wrap\_kv\_option} (key, value)}

Format a \texttt{key=value} option.

\noindent If \luavar{value} is given a \value{key=value} pair is returned,
otherwise only the \luavar{key}.

\begin{minted}{lua}
self:wrap_kv_option('color', 'true')
=> 'color=true'

self:wrap_kv_option('color')
=> 'color'
\end{minted}


\paragraph{\luavar{wrap\_macro} (name, value(s))}

Wrap a value in a macro.

\noindent Wrap an arbitrary number of values in a \LaTeX\ macro. \luavar{name}
defines the macro to be used (without the leading backslash), while the
remaining (zero to nine) arguments are added as macro arguments. If \emph{no}
arguments are provided one empty argument (or separator) will be added anyway.
If one argument is not a string but an array table its first (or only) argument
will be used as the macro's \emph{optional} argument. (This is independent from
the optional argument's position, although it would be most naturally put at the
beginning or the end of the argument list.)

\begin{minted}{lua}
self:wrap_macro('mbox', 'Box this')
=> '\mbox{Box this}'

self:wrap_macro('textcolor', 'red', 'colored text')
=> '\textcolor{red}{colored text}'

self:wrap_macro('rule', '3cm', '1em', { '-0.5ex' })
=> '\rule[-0.5ex]{3cm}{1em}'

self:wrap_macro('myCustomMacro', { 'has only an optional argument' })
=> \myCustomMacro[has only an optional argument]
\end{minted}


\paragraph{\luavar{wrap\_optional\_arg} (opt)}

Wrap an optional argument.

\noindent Wrap a given argument in square brackets if one is present, otherwise return an empty string.

\begin{minted}{lua}
self:wrap_optional_arg('width=2cm')
=> '[width=2cm]'

self:wrap_optional_arg('')
=> ''
\end{minted}


\paragraph{\luavar{write\_latex} (text)}

Write some text to \LaTeX.

This is a convenience function to write a string to \LaTeX, without worrying
whether it is a long or other multiline string.  This is used from
\luavar{Formatters:\_write} and should generally not be used by package code.


\section{Advanced Formatter Programming}
\label{sec:advanced-programming}


\subsection{The \LaTeX\ Macro Lifecycle}
\label{sec:latex-macro-lifecycle}

Maybe the core functionality of the \luaformatters\ package is the
automatic creation of \LaTeX\ macros from defined \term[Formatter]{Formatters}.
And while this should generally be quite intuitive there may at some point arise
the desire or the need to know in more detail what happens to the formatters,
and when which information is present and what action is taken.

In the \term{Formatters Table} the package author defines, declares and
configures \term[Formatter]{Formatters}, but at that point \LaTeX\ macros are
not yet created. Instead \term[Formatter Entry]{Formatter Entries} are prepared
in the \luavar{FormattersTable}'s subtable \luavar{formatters}.  These are
processed when the \term{Formatters Table} is added to the library using
\cmd{addLuaFormatters} from \LaTeX\ or \mintinline{lua}{lua_formatters:add()} from
within a Lua file.  At that point the formatter \emph{entries} are converted to
actual \luavar{Formatter} \emph{objects} (see
\vref{sec:advanced:the-formatter-class}), and \LaTeX\ macros are created.

The form of the macros may be surprising since it does not at all resemble the
macros shown throughout this manual (e.g. \luaMacroDocInline{image}).  The
\LaTeX\ macro does not perform any of the work it is supposed to do by itself,
instead it invokes the function \mintinline{lua}{lua_formatters:write({
<formatter>, <color> }, <arguments>)}, which will \emph{then} perform the actual
work.  It will locate the correct \term{Formatter}, call its \luavar{apply()}
method with the correctly mapped arguments, take the result string and
optionally wrap it in a \cmd{textcolor} macro.  The \emph{actual} macro for the \cmd{image} command looks like this (reformatted for better readability):

\begin{minted}{tex}
\newcommand{\image}[2][width=2cm]{%
  \directlua{
    lua_formatters:write(
      { 'image', 'nocolor' },
      {
        options = "\luatexluaescapestring{\unexpanded{#1}}",
        image = "\luatexluaescapestring{\unexpanded{#2}}"
      }
    )
  }
}
\end{minted}

\noindent This has a few implications:

\begin{itemize*}
\item The Lua code defined in formatter functions will be executed when the
macro is \emph{invoked}, not at some earlier point, e.g. when it is
\emph{created}.  This means that the formatter has access to the environment at
the time of invocation, which corresponds to regular macro expansion.
\item The resulting string may include macro calls, both standard ones like
\cmd{emph} \emph{and} macros defined through \luaformatters\.  These are
written back to the \LaTeX\ document where they will be parsed \emph{next},
possibly invoking the next \luaformatters\ formatter.
\item This may or may not influence the behaviour with regard to “fragile“
commands.  Generally, if the formatter is able to “serialize” the data to
regular \LaTeX\ code it may be more robust than regular coding, but of course
when it comes to issues like inserting footnotes in floating environments there
is nothing to be gained from this approach.
\item A \luaformatters\ macro must not include itself in the code
written back to \LaTeX\ in order to avoid loops, but of course this is not
possible with regular macro expansion either.
\end{itemize*}


\subsection{Table Structure and Object Relations}
\label{sec:advanced:tables-and-objects}

In general it is not necessary to know the implementation details of
\luaformatters\ to be able to use it, and even for more advanced
techniques the tools described so far should be sufficient to work with the
package.  However, since some of the more fancy functionality is achieved
through non-obvious metatable machinery it seems necessary to provide explicit
documentation of the tables and objects involved, both for future maintenance of
the package and possibly for advanced formatter programming.

The goal of this section is not a thorough discussion of the actual
\emph{implementation} -- the source code is commented pretty thoroughly -- but
rather to give a high-level idea how the pieces fit together, and what material
is available for use in formatter programming.

This is the overall table structure:

\medskip

\dirtree{%
.1 'lua\_formatters' (Formatters object).
.2 \_clients (table of FormattersTable objects).
.3 'builtins' (FormattersTable object).
.3 {...} (other clients).
.2 \_formatters (table of tables).
.3 'builtins' (table).
.4 bold (Formatter object).
.4 superscript (Formatter object).
.4 {...} (further formatters).
.3 {...} (other clients).
}

\bigskip

\dirtree{%
.1 client (FormattersTables object).
.2 {...} (properties).
.2 formatters (table).
.2 configuration (table).
.2 \_local (table).
.2 \_local\_formatters (table).
}

\bigskip

\dirtree{%
.1 Formatter.
}


\subsubsection{The \luavar{lua\_formatters} Object}
\label{sec:advanced:the-lua-templates-object}

Upon loading of the \luaformatters\ package one \luavar{Formatters} table
is created and made available as the global variable \luavar{lua\_formatters}.
This will become the \term{Formatters Library} holding all registered
\term[Client]{Clients} and being called from the generated macros.  It also
provides the library handling functionality documented elsewhere:

\begin{itemize*}
\item \luavar{Formatters:new} -- create a new \luavar{FormattersTable} (client) instance
\item \luavar{Formatters:add} -- register a new client to the library
\item \luavar{Formatters:format} -- apply a registered formatter
\item \luavar{Formatters:formatter} -- locate a registered formatter (from any client)
\item \luavar{Formatters:write} -- apply a formatter and write the result to \LaTeX
\end{itemize*}

\noindent In addition to these the support functions that are described in
\vref{sec:defining:support-functions} and defined in the submodule
\luavar{submodules/luaformatters-support.lua} are referenced to become fields of
the \luavar{Formatters} table.

\luavar{lua\_formatters} holds two corresponding \emph{stacks} --
\luavar{\_clients} and \luavar{\_formatters} -- that are handled in LIFO order:
when looking up a formatter the clients are searched in reverse order of
addition.  Whenever a client is added through \luavar{lua\_formatters:add()}
entries are added to both stacks.
The \luavar{\_clients} subtable holds objects of the \luavar{FormattersTable}
class (\vref{sec:advanced:templates-table}) that have been created in
packages/documents and are added as \term[Client]{Clients} to the
\term{Formatters Library}.  The entry in the \luavar{\_formatters} subtable is
populated automatically upon the addition of a client, and it will hold a flat
list whose keys are virtual paths (strings in Lua-style dot-notation) to which
\luavar{Formatter} objects (\vref{sec:advanced:the-formatter-class}) are
assigned.  These \luavar{Formatter} objects too are created implicitly while the
client is being added to the library.  A hyphothetical \luavar{\_formatters} table might look like this:

\begin{minted}{lua}
lua_formatters = {
	_clients = {
		['my-package'] = {
			['foo'] = <Formatter object for \foo>,
			['bar.baz'] = <Formatter object for \barBaz>
		}
	}
}
\end{minted}

\noindent In this reference list formatters are stored by their (potentially
nested) \emph{keys} referring to their position in the original
\luavar{FormattersTable} instance.  Additionally each formatter stores its macro
name, which often differs from the key, and upon formatter lookup both the key
and the internal name are considered.



\subsubsection{\luavar{FormattersTable} -- The Client}
\label{sec:advanced:templates-table}

The \luavar{FormattersTable} class is the basic entity a package author is
confronted with: one \term{Client} is defined within one \term{Formatters Table},
instantiated with \mintinline{lua}{lua_formatters:new_client(<name>)} (or a table as
argument).  It can be given a few properties (see
\vref{sec:usage:templates-table}), and the \luavar{formatters} (mandatory) and
\luavar{configuration} (optional) subtables have to be populated with formatter
declarations.

Toplevel functions and fields created in a \luavar{FormattersTable} are sort-of
private to the client, as they can be accessed from a formatter using the
\luavar{self:} notation but not (easily) from any other code.

\subsubsection{The \luavar{formatters} Table}
\label{sec:advanced:the-formatter-table}

The mandatory field in a templates table is the \luavar{formatters} subtable,
which is populated using the commands described in
\vref{sec:usage:declaring-formatters}. It may be arbitrarily nested with further
subtables that serve both for organizing the material and for defining the
namespace of generated macro names, which are by default derived from the table
structure.  Each field (with the exception of subtable nodes) is expected to be
a valid \emph{formatter entry} (see \vref{sec:usage:formatter-entries}),
declaring and/or implementing a single \emph{formatter} (which will later be
converted to a proper \luavar{Formatter} object).


\subsubsection{The \luavar{configuration} Table}
\label{sec:advanced:the-configuration-table}

An optional subtable \luavar{configuration} may be used to either provide
additional configuration data to formatters
(\vref{sec:usage:configuring-formatters}) or to create \LaTeX\ macros from
built-in (\vref{sec:usage:publishing-builtin-formatters}) or other hidden
formatters.  The table is a flat table whose keys are formatter keys in
dot-notation strings, and it is populated using the methods described in
\vref{sec:usage:configuring-formatters}.


\subsubsection{Functions of the \luavar{FormattersTable} Class}
\label{sec:advanced:templates-table-functions}

\NOTE{TBD}


\subsection{The \luavar{Formatter} Class}
\label{sec:advanced:the-formatter-class}

When formatters are actually in \emph{use} they have been silently converted to
instances of the \luavar{Formatter} class, and some knowledge about this class
is relevant for creating all but very simple formatters.

The formatter has a number of properties that have partially been provided in
the \term{Formatters Table} and partially inferred from various sources.  The
properties are stored in private fields whose names start with underscores, but
there are accessor methods that should be used when querying the properties
(because some of the properties are only generated and cached upon first
request).

These properties and the functions described below are accessible from a
formatter function using the \luavar{self:} notation.  In addition a formatter
function can access:

\begin{itemize*}
\item The “parent” table (the \term{Client} that has created this formatter)
(through \luavar{self:})
\item \luavar{lua\_formatters} (and through this the support functions) (through
\luavar{self:})
\item Local formatters (through \luavar{self:\_format()})
\item Global formatters (through \luavar{self:format()})
\end{itemize*}

Access to the \luavar{FormattersTable} object is described in
\vref{sec:advanced:templates-table-functions}, to (local and global) formatters
in \vref{sec:advanced:modular-design-principles}.


\subsubsection{\luavar{Formatter} Properties}
\label{sec:advanced:formatter-properties}

The following list describes the properties of a \luavar{Formatter} object.

\begin{itemize*}
\item \luavar{Formatter:args()}\\
The \luavar{args} property is a (potentially) empty array of macro argument
names.  It is generated upon first request (depending on the internal
formatter's type) and cached.  Note that this may fail for string templates if
there's a mismatch between (number or name) of \luavar{args} given in the
\term{Formatter Entry Table} and the template fields.

\item \luavar{Formatter:color()}\\
The \luavar{color} is the color to be used for the formatter. It can be the
name of a color, \luavar{'default'} (which is also the default value) or
\luavar{'nocolor'} (see  \vref{sec:coloring}).

\item \luavar{Formatter:comment()}\\
The comment for the self-documentation, or an empty string.

\item \luavar{Formatter:fields{}}\\
An array with named replacement fields in a string template.  If the formatter
is not template- but function- based it is an empty table.  The order of
appearance in the template is preserved, and duplicates are suppressed (if a
field is used more than once).  If an \luavar{<<<options>>>} field is present it
is stored in the first position.

\item \luavar{Formatter:has\_options()}\\
Returns the \emph{position} of the optional argument if the formatter has one,
or \luavar{nil} if it doesn't.  For string templates the optional argument is
always stored in the first position while functions may place the
\luavar{options} argument in an arbitrary position.

\item \luavar{Formatter:is\_func()}\\
Returns \luavar{true} if the formatter is function-based, \luavar{false} if it
is template-based.

\item \luavar{Formatter:is\_hidden()}\\
Returns \luavar{true} if the \luavar{name()} property starts with an underscore.

\item \luavar{Formatter:key()}\\
The \luavar{key} is the property by which a formatter is addressed and looked
up.  It is a string value in Lua-style dot-notation that is determined
automatically by the (nested) position the \term{Formatter Entry} had in the
\term{Formatters Table}.

\item \luavar{Formatter:macro()}\\
Returns the generated \LaTeX\ macro for the formatter, or \luavar{nil} if it is
considered a hidden formatter.  It is usually not necessary to access this
property directly.

\item \luavar{Formatter:name()}\\
The macro name of the formatter.  This is either specified explicitly or
generated from the \luavar{key} and the client's \luavar{prefix}
(\vref{sec:usage:macro-names}).

\item \luavar{Formatter:parent()}\\
The \luavar{parent} of a formatter is the \term{Client} from which it has been
created.  If a formatter is initially defined to be hidden by the client and
later published by another client, the \luavar{parent} is still the original
client.%
\footnote{\NOTE{TODO:} \url{https://github.com/uliska/luaformatters/issues/34}}


\item \luavar{Formatter:template()}\\
If the formatter has a template registered it can be retrieved using this
property.  Otherwise \texttt{nil} is returned.
\end{itemize*}


\subsubsection{\luavar{Formatter} Functions}
\label{sec:advanced:formatter-functions}

The following paragraphs describe the publicly available functions of a
\luavar{Formatter} object.  Note that only \luavar{check\_options()},
\luavar{\_format()}, \luavar{is\_formatter()} and \luavar{replace()} are
\emph{intended} for public use.


\paragraph{\luavar{Formatter:apply(...)}}
\label{sec:advanced:formatter:apply}

is the function that is implicitly called by \luavar{Formatters:format()}.  It is
possible to use this function too after having obtained a \luavar{Formatter}
object through \luavar{Formatters:formatter(key)}, but the canonical way of using
another formatter is \luavar{self:format(key, ...)}.  If the internal formatter
is a function then the \luavar{...} arguments are simply passed on to the
function's argument list, in case of a string templates it is more complex: The
arguments may be one out of:

\begin{itemize*}
\item A replacement table mapping field names to values
\item A single string for templates with one field
\item An array with field names plus the corresponding values as separate
arguments
\end{itemize*}


\paragraph{\luavar{Formatter:check\_options(options, ignore\_declarations)}}
\label{sec:advanced:formatter:check-options}

is the function that is implicitly called by \luavar{Formatter:apply()} to
preprocess the string passed from an optional macro argument.  It is possible to
use this function separately to process a string formatted like options (for
example if an options table contains sub-options).  To do so, the second
argument \luavar{ignore\_declarations} should be set to a non-false value to
prevent the function from validating the input against the formatter's options
declaration.

If the formatter has options declared the result will be initialized with the
default values which will be overwritten with the values of the given options.
If \luavar{options} is not a string but a table the function assumes that it has
already been validated and simply overwrites the formatter's defaults with the
values from the given table.


\paragraph{\luavar{Formatter:docstring(options)}}
\label{sec:advanced:formatter:check-docstring}

is the function that is implicitly used for populating the self-documentation
strings, and while it might be possible to make use of them otherwise there is
no actual encouragment to do so.  It will return a string that can be written back to \LaTeX.

Note that this will produce a warning and return an empty string if the \luavar {self-documentation} package option is not set. The options recognized by this command are:

\begin{itemize*}
\item \luavar{args}\\
if given this array is used to populate the arguments with actual values.
Otherwise (or if not enough args are given) the argument \emph{names} are
printed.

\item \luavar{demo}\\
if \texttt{true} in addition to the docstring an actual usage example is
typset, using \luavar{args} if given.

\item \luavar{demosep}\\
can be used to override the default value of the separator between docstring
and usage example (defaults differ between inline and environment use).

\item \luavar{nocomment}\\
suppresses the typesetting of a comment (if one is specified) in environment
docstrings.
\end{itemize*}

\paragraph{\luavar{Formatter:\_format(...)}}
\label{sec:advanced:formatter:format}

This command can be used to use formatters that are declared locally to the
current \term{Client}.  See \vref{sec:advanced:modular:local-formatters} for
details.

\paragraph{\luavar{Formatter:is\_formatter(obj)}}
\label{sec:advanced:formatter:is-formatter}

This command should be considered a \emph{class function} of the
\luavar{Formatter} class because any actual \luavar{Formatter} object is by
definition a formatter.  It is used by \luaformatters\ while iterating over a new
client to discern between formatter entries and tree nodes.  The function
returns \texttt{true} if the given object appears to be a correct
\term{Formatter Entry Table} -- or, of course, if it is an actual
\luavar{Formatter} object.


\paragraph{\luavar{Formatter:replace(template, replacements)}}
\label{sec:advanced:formatter:replace}

This command can be used like a class function to replace fields in a string
template with values given in a replacement table.  No further checks about
validity or plausibility of the arguments is done: when used from within
\luavar{Formatter:\_apply\_template()} this has already been taken care of, and
when external code wants to use the function it has to do so on its own.


\paragraph{\luavar{Formatter:update(entries)}}
\label{sec:advanced:formatter:update}

This function takes the entries of the given table and stores them in the
\luavar{Formatter} object, with the names prepended by an underscore. Note that
there should rarely be a valid use case for this function, that no checks are
performed regarding the used keys, and especially that there is no support for
any further action that might be necessary after modifying an existing
\luavar{Formatter} object.


\subsection{Modular Design Principles}
\label{sec:advanced:modular-design-principles}

One of the goals of \luaformatters\ is encouraging and simplifying the reuse of
code while developing macro libraries.  This section aims at giving an overview
of the available techniques that can be used to benefit from the package's
provisions.


\subsubsection{Acessing \luavar{lua\_formatters} Fields}
\label{sec:advanced:modular:lua-templates-fields}

The main table \luavar{lua\_formatters} (and through it, the support functions)
provides some general functionality useful in formatter programming, most
notably the \luavar{format()} function and probably the \luavar{wrap\_XXX()}
functions (\vref{sec:advanced:the-lua-templates-object}).  All these can be
directly accessed from within a formatter using the \luavar{self:} notation.


\subsubsection{Accessing Parent/Client Table Fields}
\label{sec:advanced:modular:parent-table}

A formatter can access fields of its “parent” \term{Client}'s
\luavar{FormattersTable} object that are not publicly exposed as formatters and
can be considered private to the \term{Client}. So this is the place to
implement helper functionality that is required by the actual formatters but not
intended to be shared by other code.  This somewhat competes with the concept of
\term[Local Formatter]{Local Formatters} as described in
\vref{sec:advanced:modular:local-formatters}, and there are no hard rules
regarding the choice of the solution for a given use case.  As a rule of thumb it may be a good starting point to implement functionality that “formats” data into strings, either to be printed to \LaTeX\ or to be used as building blocks in larger contexts, as “formatters” and other functionality such as complex lookup operations or mere helper routines as “functions”.

\NOTE{TODO:} Implement example: function that returns the current Git HEAD plus a flag if it's clean or dirty. Check if Git is installed and if we're in a Git repo. Return a table (with further commit information(?)).



\subsubsection{Using Registered Formatters}
\label{sec:advanced:modular:formatters}

All formatters that have been registered in the current or any other client can
be used from a formatter.  It is important to keep in mind that the order in
which \term[Client]{Clients} are registered does \emph{not} affect the ability
of using formatters.  When clients are added to the library their macros are
created, but these macros are only \emph{invoked} at a much later stage, when
\emph{all} packages have already been processed and their macros created.

There are \emph{other} aspects where the order of addition to the library
\emph{does} matter, though:  formatters are generally looked up in the reverse
order of their client's addition to the library, so if there should be multiple
formatters with the same lookup key, the one added last will shadow any other
formatter.%
\footnote{\NOTE{NOTE:} The behaviour for name clashes is not finally decided.
See \url{https://github.com/uliska/luaformatters/issues/34}.}

Registered formatters are used using

\begin{minted}{lua}
self:format(<key>, ...)
\end{minted}

A registered formatter is looked up, first by its \luavar{key} then by its \luavar{name}, by default in all clients, searching in reverse order of the client's addition.  If necessary it is also possible to address a specific client:

\begin{minted}{lua}
self:format({ <client-name>, <key> }, ...)
\end{minted}

\noindent The arguments passed to \luavar{format()} have to match the expected arguments of the formatter.

If no formatter with the requested key/name is found an error is raised and the
compilation aborted.  If it is not known whether a given formatter is available
(for example when asking for a formatter from another \LaTeX\ package)
\luavar{format()} shouldn't be called directly, rather one should first locate
the formatter and then conditionally \luavar{apply()} it:

\begin{minted}{lua}
local f = self:formatter(<key>)
if f then
	f:apply(<args>)
else
	<do-something-else or report>
end
\end{minted}

\noindent This approach may be useful to make use of some functionality of
another package but provide fallback functionality if that package isn't loaded.

The example macro \luaMacroDocInline{Bar} (listing in
\vref{sec:examples:using-formatters}) makes use of the formatter \luavar{foo}
(defined in the \luavar{MANUAL} \luavar{FormattersTable}) and also shows the
safety check (even if that isn't necessary when the used formatter is
\emph{known} to be available). The formatter iterates over the characters in the
\luavar{text} argument and replaces each with the result of calling
\luavar{foo()} on it.  The automatically generated macro could be used like
\luaMacroDocInline[demo,args=Foo]{Bar}.


\subsubsection{Using Built-in Formatters}
\label{sec:advanced:modular:builtin-formatters}

Using the built-in formatters described in \vref{sec:defining:builtin-formatters} is basically a special case of using arbitrary formatters, except that it is guaranteed that they are loaded.


\subsubsection{Using Local Formatters}
\label{sec:advanced:modular:local-formatters}

Formatters that have been defined as \term[Local Formatter]{Local Formatters}
can be applied using \luavar{self:\_format(<key>, <args>)} (note the leading
underscore in the function which in this case signifies a local
\emph{formatter}, not a private function). The command \luaMacroDocInline{dv}
(“Deutsch-Verzeichnis”) builds upon the \luaMacroDocInline{DV} example from
\vref{sec:defining:styles}, adding some smarter functionality: not only does it
ensure orthotypgraphic consistency prepending the catalogue abbreviation but it
also ensures consistent typesetting of the catalogue number and its possible
sub-entry.  The function is listed in \vref{sec:examples:local-formatters}, and
the following entries are all printed consistently:

\begin{itemize*}
\item \luaMacroDocInline[demo, args={550}]{dv}
\item \luaMacroDocInline[demo, args={911/15}]{dv}
\item \mintinline{tex}{\dv{911,16}}: \dv{911,16}
\item \mintinline{tex}{\dv{911, 16}}: \dv{911, 16}
\end{itemize*}

\noindent This formatter makes use of a pretty common idiom: Formatting a one-argument string template with the result of a second (local) formatter:%
\footnote{Since this is so common it is intended to provide some syntactic sugar
to make it even more convenient to use
(\url{https://github.com/uliska/luaformatters/issues/33}).}

\begin{minted}{lua}
function LOCALS.formatters:dv(text)
    return self:format('DV', self:_format('work-number', text))
end
\end{minted}


\section{Examples}
\label{sec:examples}

\subsection{Minimal Working Example}
\label{sec:examples:mwe}

\noindent
\texttt{luaformatters-mwe.lua} and \texttt{luaformatters-mwe.tex}:

\inputminted{lua}{examples/luaformatters-mwe.lua}

\hrule

\inputminted{tex}{examples/luaformatters-mwe.tex}

\directlua{os.execute('lualatex -jobname=examples/luaformatters-mwe examples/luaformatters-mwe.tex')}

\includepdf{examples/luaformatters-mwe}


\subsection{A Sample Configuration File}
\label{sec:examples:manual-templates}

The following listing shows the working configuration file
\texttt{luaformatters-manual-templates.lua} which is actually used for producing
this manual. It is thoroughly commented and aims at being a concise but
comprehensive demonstration of the available tools and options.  In order to
achieve this goal it is obviously less cleanly structured than a real-world file
would be, and it is planned to add further example files demonstrating
particular techniques and approaches.

\inputminted[firstline=11]{lua}{luaformatters-manual.lua}

\enlargethispage*{4\baselineskip}

\subsection{Real-World Example}
\label{sec:examples:real-world-example}

The following file is copied from a real-world example to demonstrate a number of techniques.  Note that \emph{all} of the project's dedicated macros have been concentrated in this Lua file, but note also that it will probably not be directly usable outside of that context.

\inputminted{lua}{examples/luaformatters-schubert.lua}


\subsection{Specific Examples}
\label{sec:specific-examples}

The following examples serve as demonstrations of specific techniques.  Some of
them are taken from the functionality created for this manual and moved to
separate files which are all added as \term[Client]{Clients} to the manual's
\term{Formatters Library}, while others are created separately and are accessible
through corresponding \texttt{.tex} files in the \texttt{documentation/examples}
subdirectory of the repository.


\subsubsection{Using Formatters}
\label{sec:examples:using-formatters}

\inputminted{lua}{examples/luaformatters-format.lua}


\subsubsection{Local Formatters}
\label{sec:examples:local-formatters}

\inputminted{lua}{examples/luaformatters-local-formatters.lua}

\inputminted{tex}{examples/luaformatters-local-formatters.tex}


\subsubsection{Closures}
\label{sec:examples:closures}

This is in its essence not a \luaformatters\ demonstration but rather a Lua idiom, but it perfectly illustrates how the package makes it easy to exploit programming in a language like Lua.

The file \texttt{examples/luaformatters-closures.lua} is made available to \texttt{luaformatters.tex} by adding

\begin{minted}{tex}
\addLuaFormatters{examples/luaformatters-closures.lua}
\end{minted}

\noindent to the document preamble after loading the main \term{Formatters
Table}.  Basically this is done for all further examples.

\inputminted{lua}{examples/luaformatters-closure.lua}


\subsubsection{Validating the Optional Argument}
\label{sec:examples:validating-optional-argument}

\inputminted{lua}{examples/luaformatters-validate-options.lua}

\inputminted{tex}{examples/luaformatters-validate-options.tex}

\end{document}
